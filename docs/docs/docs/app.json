[{"name": "app.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Aug 25 13:33:04 2024\n\n@author: john\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport itertools\nfrom scipy.optimize import linprog\nfrom pandas import option_context\nimport Matching\nimport ReadMatchData\nimport re\n\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nimport shinywidgets\nfrom shinywidgets import render_widget, output_widget\n\nimport os\nimport signal\nfrom datetime import datetime\n\n\napp_ui = ui.page_navbar( \n    # ui.nav_panel(\"Input\",\n    #     ui.row(\n    #             ui.column(4,offset = 0,*[ui.input_file(\"file1\", \"Choose .txt File\", accept=[\".csv\", \".CSV\", \".dta\", \".DTA\",\" .txt\", \".TXT\"], multiple=False, placeholder = '', width = \"600px\")]),\n    #         ),\n\n    # ),\n    ui.nav_panel(\"Input/Linear Program\",\n        ui.row(\n                ui.column(4,offset = 0,*[ui.input_file(\"file1\", \"Choose .txt File\", accept=[\".csv\", \".CSV\", \".dta\", \".DTA\",\" .txt\", \".TXT\"], multiple=False, placeholder = '', width = \"600px\")]),\n            ),\n        ui.row(\n                ui.column(3, offset = 0,*[ui.input_action_button('generateLP',\"Generate LP\")]),\n                ui.column(3, offset = 0,*[ui.input_action_button('solveLP',\"Solve LP\")]),\n                ui.column(6, offset = 0,*[ui.input_checkbox_group(\"genoptions\",\"Options: \",choices = [\"add 1 set per firm\",\"add stability const.\",\"dualize stab. constr.\"],\n                          width = \"500px\",inline = True)]),\n            ),\n        ui.row(\n                #ui.output_data_frame(\"LPOut\"),\n                ui.output_text_verbatim(\"LPOut\"),\n                ui.output_text_verbatim(\"LPSolvedOut\"),\n            ),\n        ui.row(\n             ui.column(3, offset = 0,*[ui.input_action_button('testTU',\"Test TU: (this can take time)\")])\n            ),\n        ui.row(\n             ui.output_text_verbatim(\"TUreport\")\n            ),\n        ui.row(\n             #ui.column(3, offset = 0,*[ui.input_action_button(\"solveIt\",\"Solve LP\")])\n            ),\n        ),\n    ui.nav_panel(\"Enumeration\",\n        ui.row(\n                ui.column(3,offset=0,*[ui.input_action_button(\"datalogGo\",\"Show Data\",width = '300px')]),\n            ),\n        ui.row(\n                ui.output_text_verbatim(\"datalog\"),\n            ),\n        ui.row(\n                ui.column(3,offset=0,*[ui.input_action_button(\"goextreme\",\"Enumerate Extreme Points\",width = '300px')]),\n                ui.column(6,offset=0,*[ui.input_radio_buttons(\"stype\",\"Show: \",choices = ['All Extreme Points','Stable Extreme Points Only'],inline = True)]),\n            ),\n        ui.row(\n                ui.output_text_verbatim(\"extremelog\"),\n            ),\n        ui.row(\n                ui.column(3,offset=0,*[ui.input_action_button(\"gointersection\",\"Show Intersection Graph\",width = '300px')]),\n            ),\n        ui.row(\n                ui.output_text_verbatim(\"intgraph\"),\n            ),\n        ),\n#     ui.nav_panel(\"Optimization\",\n#                  ),\nunderline = True, title = \"Stable Matcher 2.0 \")\n                 \ndef server(input: Inputs, output: Outputs, session: Session):\n    \n    nw = reactive.value(0) # number of workers 1,..,nw\n    nf = reactive.value(0) # number of firms 1,...,fn\n    pw = reactive.value([]) #worker preferences \n    pf = reactive.value([]) # firm preferences\n    cmat = reactive.value([]) #constraint matrix (for TU checking)\n    crhs = reactive.value([]) #righthand sides\n    cobj = reactive.value({}) #objective function\n    df_LP = reactive.value(pd.DataFrame()) # Full generated LP with row and column labels for display mostly\n    solution_LP = reactive.value('') #solution to the LP as a string\n    imat_G = reactive.value([]) #incidence matrix of the intersection graph\n    teams_LP = reactive.value([]) #the team that goes with each column of cmat or df_LP\n    firms_LP = reactive.value([]) #the worker that goes with each column of cmat or df_LP\n    stab_constr_LP = reactive.value([]) # just the stability constraint coefficients\n    \n    @reactive.calc\n    def parsed_file():\n        print(f\"$$$$$$$$$$$$$$$$$$Path: {str(input.file1()[0]['datapath'])}\")\n        if input.file1() is None:\n            return('')\n        else: #Note the ui passes only paths ending in  .csv, .CSV, .dta, .DTA and .txt\n            fpath = str(input.file1()[0]['datapath'])\n            print(f\"$$$$$$$$$$$$$$$$$$Path: {fpath}\")\n            if (fpath[-4:] == '.txt') or (fpath[-4:] == '.TXT'):\n                nwt,nft,pwt,pft = ReadMatchData.readData(fpath)\n            #print(f'@@@@@@@@@@@@@@@@nw = {nwt}')\n            nw.set(nwt)\n            nf.set(nft)\n            pw.set(pwt)\n            pf.set(pft)\n            outstr = ''\n            #print(f\"***************pwt[1] = {pwt[1]}\")\n            for ix in range(1,nf()+1):\n                outstr = outstr + f\"pf[{ix}] = {pf()[ix]} \\n\"\n            for ix in range(1,nw()+1):\n                outstr = outstr + f\"pw[{ix}] = {pw()[ix]}\\n\"\n            #print(outstr)\n            return( nft)\n\n\n    @render.text\n    @reactive.event(input.datalogGo)\n    def datalog(): \n        nft = parsed_file()\n        nwt = nw()\n        nft = nf()\n        pft =  pf()\n        pwt = pw()\n\n        if (nwt == 0): \n            print(\"**********quitting no data*************\")\n            return\n        outstr = ''\n        for ix in range(1,nft+1):\n            outstr = outstr + f\"pf[{ix}] = {pft[ix]} \\n\"\n        for ix in range(1,nwt+1):\n            outstr = outstr + f\"pw[{ix}] = {pwt[ix]}\\n\"\n        return(outstr)\n  \n\n    @render.text\n    @reactive.event(input.goextreme)\n    def extremelog():\n        nft = nf()\n        nwt = nw()\n        pft = pf()\n        pwt = pw()\n\n        #const_mat,rhs,obj,firms,teams,rowlab,stab_constr = Matching.doLP(nwt, nft, pwt, pft, DoOneSet = oneper, DoBounds = False, StabilityConstraints = dostab, Dual = False, Verbose = False)\n        imat = Matching.doIntersectionGraph(cmat())\n        imat_G.set(imat)\n        if (input.stype() == \"All Extreme Points\"): \n            vbs = True\n        else:\n            vbs = False\n        if \"add stability const.\" in input.genoptions():\n            outstring = \"The enumeration process for extreme points requires a non-negative binary constraint matrix.\\n  Remove the stability constraints and try again!\"\n        else:\n            independent_columns, outstring = Matching.doIndependentSets(imat,teams_LP() , firms_LP(), StabConst = stab_constr_LP(), Verbose = vbs)\n        return(outstring)\n\n    @reactive.effect\n    @reactive.event(input.generateLP)\n    def formulate_LP():\n        nft = parsed_file()\n        solution_LP.set('')\n        nwt = nw()\n        nft = nf()\n        oneper = False\n        dostab = False\n        print(f\"  formulate_LP :: #workers: {nwt}, #firms: {nft}, oneper: {oneper}, dostab: {dostab}\")\n        if nw() == 0: \n            return        \n        oneper = False\n        dostab = False\n        dodual = False\n        if (\"add 1 set per firm\" in input.genoptions()):\n            oneper = True\n        if (\"add stability const.\" in input.genoptions()):\n            dostab = True\n        if (\"dualize stab. constr.\" in input.genoptions()):\n            dodual = True\n        cols, rhs, obj, firm_no, set_assgn, rowlabels, stab_columns = Matching.doLP(nw(), nf(),pw(),pf(),DoOneSet = oneper, DoBounds = False, StabilityConstraints=dostab, Dual = dodual)\n        dfout = Matching.displayLP(constraints = cols, rhs = rhs, obj = obj, teams = set_assgn, firms = firm_no, rowlabels = rowlabels)\n        df_LP.set(dfout)\n\n        cmat.set(cols)\n        cobj.set(obj)\n        crhs.set(rhs)\n        teams_LP.set(set_assgn)\n        firms_LP.set(firm_no)\n        stab_constr_LP.set(stab_columns)\n\n    #@render.data_frame\n    @render.text\n    @reactive.event(input.generateLP)\n    def LPOut():\n        dflocal = df_LP()\n        if len(dflocal) == 0:\n            return\n        return dflocal.to_string() + '\\n' + solution_LP()\n        #return dflocal\n\n    @reactive.effect\n    @reactive.event(input.solveLP)\n    def goSolve():\n        #now solve it\n        results,status = Matching.solveIt(cmat(), crhs(), cobj())\n        outstring = Matching.decodeSolution(firms = firms_LP(), teams = teams_LP(),  solution = results)\n        solution_LP.set(outstring)\n\n\n    #@render.data_frame\n    @render.text\n    def LPSolvedOut():\n        return solution_LP()\n\n\n    @render.text\n    @reactive.event(input.gointersection)    \n    def intgraph():\n        return(np.array_str(imat_G()))\n    \n    @render.text\n    @reactive.event(input.testTU)\n    def TUreport():\n        ISTU, outstring = Matching.checkTU(cmat(),Verbose = True, Tol = 1e-10)\n        return outstring\n\n\napp = App(app_ui, server,debug=True)\n\n\n", "type": "text"}, {"name": "Matching.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jul 26 09:12:33 2024\n\n@author: john\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport itertools\nfrom scipy.optimize import linprog\nfrom pandas import option_context\n\ndef solveIt(CONSTRAINTS =  [], RHS = [], OBJ = [],Verbose = False):\n    linprogstat = [\"Optimization Nominal\", \"Iteration Limit Reached\", \"Infeasible\", \"Unbounded\",\"Numerical Problems, call a professional.\"]\n    if Verbose:\n        print(\"#####################\")\n        print(\"### Solving ##########\")\n        print(\"#####################\")\n    if (len(CONSTRAINTS) == 0): \n        print(\"No constraint matrix specified. Quitting.\")\n        return\n    \n    nr, nc = CONSTRAINTS.shape\n    bds = [(0,1) for ix in np.arange(0,nc)]\n    if len(RHS) == 0:\n        RHS = np.ones((nr,1))\n    if len(OBJ) ==0:\n        OBJ = np.ones((nc,1))*-1\n    lp_results = linprog(c = OBJ, A_ub = CONSTRAINTS, b_ub = RHS, bounds = bds)\n    if Verbose:\n        if lp_results.status == 0:\n            print(\"Optimization successful\")\n        else:\n            print(f\"optimization less than successful. Status: {linprogstat[lp_results.status]}\")\n            return([],lp_results.status)\n        print(f'Objective : {lp_results.fun}')\n        print(f'Solution: {lp_results.x}')\n        ISINT = [min(np.abs(item-0),np.abs(item-1)) for item in lp_results.x]\n        MXI = max(ISINT)\n        if (MXI > 0.000005): print(\"Solution not integer!\") \n        else: print(f\"Solution integer. Tolerance: {MXI}\")\n    return(lp_results.x,lp_results.status)\n    \ndef checkTU(mat,Verbose = False, Tol = 1e-10):\n    if Verbose:\n        print(\"#####################\")\n        print(\"### Checking TU #####\")\n        print(\"#####################\")\n    (nrow,ncol) = mat.shape\n    maxsize = min(nrow,ncol)\n    cursize = 2\n    count = 0\n    outstring = ''\n    ISTU = True\n    while cursize <= maxsize :\n        #choose all cursize x cursize sub-matrices \n        rowsets = list(itertools.combinations(set(np.arange(0,nrow)),cursize))\n        colsets = list(itertools.combinations(set(np.arange(0,ncol)),cursize))\n        for ix in rowsets:\n            for jx in colsets:\n                a = mat[ix,:]\n                b = a[:,jx]\n                d = np.linalg.det(b)\n                print(\"\\nTesting\")\n                print(np.array_str(b))\n                print(f\"Determinant: {d}\")\n                count = count +1\n                if (np.abs(d)>Tol) & (np.abs(d-1)>Tol) & (np.abs(d+1)>Tol): \n                    ISTU = False\n                    if Verbose:\n                        return ISTU, f\">>Is NOT TU<< \\n Determinant: {d} \\n iteration: {count}, \\n Submatrix: \\n {np.array_str(b)}\"\n                    else: \n                        return ISTU\n        cursize += 1 \n    if Verbose:\n        return ISTU, f\">>IS TU<< Number of determinants tested: {count}\"\n    else:\n        return ISTU\n\n\ndef firmPref(ifirm, preflist, set1, set2):\n    prefers = False\n    if set2 in preflist[ifirm]:\n        if preflist[ifirm].index(set1)  <  preflist[ifirm].index(set2):\n            prefers = True\n        else:\n            prefers = False\n    else:\n        prefers = False\n    return(prefers)\n\ndef workerPref(iworker, preflist, firm1, firm2):\n    prefers = False\n    if firm1 not in preflist[iworker]:\n        prefers = False\n    else:\n        if firm2 in preflist[iworker]:\n            if preflist[iworker].index(firm1) < preflist[iworker].index(firm2):\n                prefers = True\n            else:\n                prefers = False\n        else:\n            prefers = False\n    return(prefers)    \n    \n    \n    \ndef doLP(nw, nf, pw = [], p=[], DoOneSet = True, DoBounds = False, StabilityConstraints = True, Dual = False, Verbose = False):\n    if Verbose:\n        print(\"#############################\")\n        print(\"### Generating LP Model #####\")\n        print(\"#############################\")\n    if len(p) == 0:\n        print(\"No firm preferences specified, quitting.\")\n        return([],[],[],[])\n    firm_no = list() #firm for each column\n    set_assgn = list() #set for each column\n    set_ind = np.zeros((nw+1,1))\n    #*******************************************\n    #construct the incidence matrix column-wise\n    #*******************************************\n    for ix in range(1,nf+1,1): #for each firm 1,...,nf\n        for jx in range(0,len(p[ix]),1): #and each set in that firm's preference list\n            #create a characteristic or indicator vector (0 if a worker is not in the set 1 if worker is)\n            #a and b are 0 offset lists, pw and p start at 1 --the 0 entry is empty\n            a = [1 if item in p[ix][jx] else 0 for item in range(1,nw+1,1)] #the assigned team's characteristic vector\n            #a[item] = 1 if worker # item = 1 is in the jx-th subset of firm i's preference list\n            b = [1 if ((a[itx]==1) & (ix not in pw[itx+1])) else 0 for itx in range(0,nw,1) ] #b[itx]=1 if worker itx+1 will not work for firm ix\n            #check that non-individually rational team assignments that have been dropped\n            #for ixq in range(0,len(b),1): if (b[ixq] == 1): print(f\"Worker {ixq+1} will not work for firm {ix}\") \n            if (sum(b) > 0): continue #at least one worker in this set will not work for firm ix this team is not individually rational for the workers drop it\n            a = [0]+ a  #row entries start at row 1 not row 0\n            set_ind = np.column_stack((set_ind,a))\n            firm_no.append(ix)\n            set_assgn.append(p[ix][jx])\n    set_ind = np.delete(set_ind,0,1)\n    set_ind = np.delete(set_ind,0,0)\n    nr, nc = set_ind.shape\n    #print(f\">>>>>>>>  After team incidence matrix rows = {nr} columns = {nc}  <<<<<<\")\n    rhs = np.ones((nr,1))\n    rowlabels = list(range(1,nw+1))\n    #columns are now set, construct objective \n    obj = np.zeros(nc)\n    #*******************************************\n    #now add the side constraints of one subset per firm\n    #*******************************************\n    if DoOneSet == True:\n        for ix in range(0,nf):\n            c = [1 if firm_no[kx] == ix+1 else 0 for kx in range(0,nc)]\n            set_ind = np.row_stack((set_ind,c))\n            rhs = np.append(rhs,1)\n            rowlabels.append(\"One set to a firm.\")\n    #righthand side up to this point is 1\n#    (nrow,ncol) = set_ind.shape\n#    rhs = np.ones((nrow + nf + len(firm_no),1))\n#    rhs[nc:len(rhs),0] = -1\n    \n    #*******************************************\n    #now add the variable bounds (not needed may tighten LP relaxation)\n    #*******************************************\n    if DoBounds ==  True:\n        for ix in range(0,nc):\n            newrowu = np.zeros((1,nc))\n            newrowu[0,ix] = 1\n            set_ind = np.row_stack((set_ind,newrowu))\n            rhs = np.append(rhs,1)\n            rowlabels.append('Variable UB')\n            newrowl = np.zeros((1,nc))\n            newrowl[0,ix] = -1\n            set_ind = np.row_stack((set_ind, newrowl))\n            rhs = np.append(rhs,0)\n            rowlabels.append('Variable LB')\n    #*******************************************\n    #  now add stability constraints\n    #*******************************************\n    colset = [tuple(item) for item in set_assgn]\n    colname = list(zip(firm_no,colset))\n    stab_columns = np.ones((1,len(colname))) * 0\n    rowlabels_stab = []\n    for item in colname:\n        ifirm = item[0]\n        iset =  item[1]\n        #start our new row\n        newrow = np.zeros(len(colname))\n        #first put a -1 in column corresponding to current firm/team pair\n        newrow[colname.index((ifirm,iset))] = -1\n        #now scan across all of the columns and put -1's in for all teams that ifirm prefers to iset (has to be a set in ifirms preference relation then ifirm has to prefer it)\n        for setitem in colname:\n            colno = colname.index(setitem)\n            if (setitem[0] != ifirm):\n                continue\n            if (firmPref(ifirm,p,set(setitem[1]),set(iset))):\n                newrow[colno] = -1\n        #now the hard part: for every worker in iset scan all firm/set pairs put a 1 in the column if worker j prefers that firm and is in that set.\n        for iwk in iset:\n            for item_w in colname:\n                colno_w = colname.index(item_w)\n                ifirm_w = item_w[0]\n                iset_w = item_w[1]\n                if workerPref(iwk,pw,ifirm_w,ifirm):\n                    if (iwk in iset_w):\n                        newrow[colno_w] = -1\n        if Dual:\n            obj = obj + newrow*(1)\n        else:\n            #set_ind = np.row_stack((set_ind,newrow))\n            stab_columns = np.row_stack((stab_columns,newrow))\n            rhs_stab = np.append(rhs,-1)\n            rowlabels_stab = rowlabels_stab + ['Stability' ]\n    stab_columns = stab_columns[1:,:] #adjust out the initial column of all zeros\n    if  not Dual:\n        obj = obj - 1\n    if StabilityConstraints:\n        nrs,ncs = stab_columns.shape\n        rhs_stab = -1*np.ones((nrs,1))\n        rhs = np.append(rhs, rhs_stab)\n        rowlabels = rowlabels + rowlabels_stab\n        #set_ind = np.row_stack((set_ind,stab_columns[1:,:]))\n        set_ind = np.row_stack((set_ind,stab_columns))\n\n    return(set_ind, rhs, obj, firm_no, set_assgn,rowlabels,stab_columns)\n    \n#format, display and save the constraint matrix\n#constraints:  each column is a firm/team assignment first nw rows are the team indicators\n#              second nf rows are the one-subset-to-a-firm constraints\n#              next set of rows (one for each firm/team pair) are the stability constraints\n#              optionally can generate upper and lower bounds for each variable\n#              default objective function is all 1's\n#teams = the team for each column\n#firms = the firm # for each column\n\n\ndef displayLP(constraints = [], rhs = [], obj = [], teams = [], firms = [],rowlabels = []):\n    colset = [str(item) for item in teams]\n    colname = list(zip(firms,colset))\n    #colname = [(item[0],set(item[1])) for item in colname]\n    constraints = pd.DataFrame(data = constraints, columns=colname)\n    constraints['RHS'] = rhs\n    constraints['RowLabels'] = rowlabels\n    constraints.index = [item+1 for item in constraints.index]\n    constraints.loc[constraints.index.max() + 1] = list(obj) + [' ','OBJ']\n    constraints.to_csv(\"LPmodel_2.csv\")\n    return(constraints)\n\ndef decodeSolution(firms = [], teams = [],  solution = []):\n    if (len(firms)== 0): \n            msgtxt = \" Input: three vectors of length equal to number of columns in LP.\\n\"\n            + \" firms= afirm for each column, teams = a set of workers for each column, \\n\"\n            +   \" solution = solution vector of length = # columns\"\n            print (msgtxt)\n    outstring = ''\n    for zx in range(0,len(solution)):\n        if solution[zx] > 0.0:\n            outstring = outstring + f\"Firm: {firms[zx]}, Assigned Set: {teams[zx]} weight:{solution[zx]} \\n\"\n    return(outstring)\n\ndef doIntersectionGraph(constraint_mat):\n    #mat is a binary array\n    nr, nc = constraint_mat.shape\n    intersection_mat = np.zeros((nc,nc))\n    #for each pair of distinct columns check to see if they have 1's in the same row (inner product > 0)\n    for ir in range(nc):\n        for ic in range(nc):\n            if (sum(constraint_mat[:,ic]*constraint_mat[:,ir]) > 0) & (ir != ic):\n                intersection_mat[ic,ir] = 1\n    return(intersection_mat)\n    \ndef doIndependentSets(inmat,teams,firms, StabConst = [],Verbose = False):\n    #very inefficient brute force enumeration\n    #enumerate all of subsets of columns\n    #inmat is the incidence matrix for the intersection graph of the constraint matrix\n    #it is n by n with n= number of columns (and in the same order) as the constraint matrix\n    nr,nc = inmat.shape\n\n    # first create a list that contains the power set of the set of columns (this is the brute force part)\n    colset = list(range(nc))\n    colsubsets = [[]]\n    for colitem in colset:\n        colsubsets += [item + [colitem] for item in colsubsets]\n\n    #print(f\" Cardinality of power set: {len(colsubsets)}\")  #just checking\n\n    #now test every subset is_inedependent \n    #is an indicator for whether or not the given subset is an independent set\n    \n    is_independent = np.ones((1,len(colsubsets))) #assume a subset of columns is independent until proven dependent\n    for indx, item in enumerate(colsubsets): #for each subset of columns\n        #item is the current subset of columns we are working on\n        #indx is the position in colsubsets where that item resides\n        if len(item) == 0: is_independent[0,indx] = 0\n        if len(item) == 1: continue\n        test_list = list(itertools.combinations(tuple(item),2)) #all sets of size 2 from the set of columns given by item\n        for xtpl in test_list:\n            if inmat[xtpl[1],xtpl[0]] == 1: #xptl[1] and xptl[2] have an arc between them (inmat is symmetric as arcs are undirected only need to check one of (i,j) and (j,i))\n                is_independent[0,indx] = 0\n                break;\n    # the list of independent sets is complete. Now reconstruct the worker subsets and firms that go with them\n    indcol = np.zeros((nc,1))\n    solution_count = 0\n    stringout = ''\n    for indx,item in enumerate(is_independent[0,:]):\n        if (item == 1): #this entry corresponds to an independent set\n            solution_count += 1\n            newstring = ''\n            newstring = newstring + f\"\\n #{solution_count}  Independent set of columns: {colsubsets[indx]}\" + \"\\n\"\n            cols = colsubsets[indx] #find the correspoinding set of workers\n            newindcol = np.zeros((nc,1)) #create a column length vector to record which contraint columns are active.\n            for item in cols:\n                newstring = newstring + f\"Firm: {firms[item]} Subset: {teams[item]}\" + \"\\n\"\n                newindcol[item,0] = 1\n            indcol = np.column_stack((indcol,newindcol))    \n            if (len(StabConst) != 0 ):\n                stabtest = np.matmul(StabConst,newindcol)\n                #newstring += f\" stability calculation :{np.array_str(stabtest[:,0])} \\n\"\n                if max(stabtest[:,0]) > -1.0 :\n                    newstring += \"----------------- Not Stable*  ---------------\\n\"\n                    if (Verbose): \n                        stringout += newstring #verbose mode:  report all matchings\n                        #stringout += f\"{np.array_str(stabtest)}\"\n                else:\n                    newstring += \"+++++++++++++++++  Stable*    ++++++++++++++++\\n \"\n                    stringout = stringout + newstring\n            else:\n                stringout = stringout + newstring\n    indcol = indcol[:,1:]\n    return(indcol,stringout)\n            \n    \nif __name__ == \"__main__\":    \n    \n###################################################################    \n###################################################################    \n###################################################################    \n###################################################################    \n###################################################################    \n    \n     \n    \n#### Test Examples H4, H8, EO19, B1\n    Example = 'B1'\n    Vbose = True\n    TestTu = False\n    if Example == 'H1':\n##############Huang Example 1\n        #no stable solution\n        nw = 3  #of workers\n        nf = 3  #of firms\n    \n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n    \n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2,3}]\n        pf[2] = [{1}, {2}]\n        pf[3] = [{2,3}]\n        \n        #enter worker preferences over firms\n        pw[1] = [1,2]\n        pw[2] = [2,1,3]\n        pw[3] = [1,3]\n#################################### \n    elif Example == 'H4':\n##############Huang Example 4\n        #stable matching: firm 1: {1,2}, firm 2: {}, Firm 3: {3}\n        nw = 3  #of workers\n        nf = 2  #of firms\n    \n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n    \n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{1,2}]\n        \n        #enter worker preferences over firms\n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1]\n#################################### \n##############Huang Example 8\n    elif Example == 'H8':\n        nw = 4  #of workers\n        nf = 2  #of firms\n    \n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{3,4}, {1,2}]\n        \n        #worker preferences over firms here\n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1,2]\n        pw[4] = [2]\n        \n    elif Example == 'EO19':\n##################################### \n###Echenique and Oviedo example 19\n        nw = 3\n        nf = 3\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,3}, {1,2}, {2,3}, {1}, {2}, {3}]\n        pf[2] = [{1,3}, {2,3}, {1,2}, {3}, {2}, {1}]\n        pf[3] = [{1,3}, {1,2}, {2,3}, {1}, {2}, {3}]  \n        \n        pw[1] = [1,2,3]\n        pw[2] = [3,2,1]\n        pw[3] = [1,3,2]\n        \n    elif Example == 'EO12':\n##################################### \n###Echenique and Oviedo example 12 no core\n        nw = 3\n        nf = 3\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{2,3}, {1}]\n        pf[3] = [{1,3}, {2}]  \n        \n        pw[1] = [1,3,2]\n        pw[2] = [2,1,3]\n        pw[3] = [3,2,1]\n    elif Example == 'EO11':\n##################################### \n###Echenique and Oviedo example 11 \n        nw = 4\n        nf = 2\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,2},{3,4}, {1,3}, {2,4}, {1},{2},{3},{4}]\n        pf[2] = [{1,2},{1,3}, {2,4}, {3,4}, {1},{2},{3},{4}]\n \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1,2]\n        pw[4] = [1,2]\n    elif Example == 'B1':\n##################################### \n### Bikhchandani substitutes/complements example\n        nw = 4\n        nf = 2\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        \n        #pf[1] = [{1,3}, {2,4},{3}]\n        #pf[2] = [{1,3}, {2,4},{4}]   \n        pf[1] = [{1,3}, {2,4}]\n        pf[2] = [{1,3}, {2,4}]   \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [2,1]\n        pw[4] = [1,2]\n    elif Example == 'B2':\n##################################### \n### Bikhchandani substitutes/complements example\n### with extra sets\n        nw = 4\n        nf = 2\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        \n        pf[1] = [{1,3}, {2,4},{3}]\n        pf[2] = [{1,3}, {2,4},{4}]   \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [2,1]\n        pw[4] = [1,2]\n        \n        \n    \n# Try an example \n    print(\"########################\")\n    print(f\" Example: {Example}\")\n    print(\"########################\")\n    \n    ####Create the constraint matrix\n    const_mat,rhs,obj,firms,teams,rowlab,stab_constr = doLP(nw, nf, pw, pf, DoOneSet = True, DoBounds = False, StabilityConstraints = False, Dual = False, Verbose = Vbose)\n    \n    dfLP = displayLP(constraints = const_mat, rhs = rhs, obj = obj, teams = teams, firms = firms, rowlabels = rowlab)\n    if Vbose:\n        with pd.option_context('display.max_rows', 50,\n                               'display.max_columns', None,\n                               'display.width', 1000,\n                               'display.precision', 0,\n                               'display.colheader_justify', 'right'):\n                  \n            print(dfLP)\n    \n    \n    \n    if TestTu:\n        IS_TU = checkTU(const_mat, Verbose = Vbose)\n        if (IS_TU):\n            print(\" Is TU\")\n        else:\n            print(\" is NOT TU\")\n        \n        \n    solution,stat = solveIt(CONSTRAINTS = const_mat, RHS = rhs, OBJ = obj, Verbose = Vbose)  \n    if stat == 0:    \n        decodeSolution(firms, teams, solution)\n    else: \n        print(\"Uh oh!\")\n        \n    imat = doIntersectionGraph(const_mat)\n    \n    with pd.option_context('display.max_rows', 50,\n                               'display.max_columns', None,\n                               'display.width', 1000,\n                               'display.precision', 0,\n                               'display.colheader_justify', 'right'):\n        print(\"constraint matrix:\")      \n        print(const_mat)\n        print(\"intersection graph incidence matrix\")\n        print(imat)\n        independent_columns,txt_out = doIndependentSets(imat, teams, firms, StabConst = stab_constr)\n        print(txt_out)\n        print(\"Extremal (integral) feasible solutions\")\n        print(independent_columns)\n        print(\"Are any of the integer solutions stable?\")\n        c = np.matmul(stab_constr,independent_columns)\n        print(c)\n\n    ", "type": "text"}, {"name": "ReadMatchData.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Aug 24 23:05:17 2024\n\n@author: john\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport re\ndef readData(fpath = 'MatchingData.txt'):\n    dfile = open(fpath, mode = 'r')\n    instring = '#'\n    wftype = ''\n    nolines = 0\n    pw = []\n    pf = []\n    while (instring != ''):\n        instring = dfile.readline()\n        if instring == '': continue\n        nolines += 1\n        #decode the type of data line: data, firm indicator, worker indicator or comment\n        if instring[:5] == 'firms' :\n            wftype = 'F'\n            nf = int(instring.split('=')[1])\n            #print(f\"Number of firms = {nf}\")\n            pf = list(range(0,nf + 1))\n            continue\n        elif instring[:7] == 'workers':\n            wftype = 'W'\n            nw = int(instring.split('=')[1])\n            pw = list(range(0,nw + 1))\n            #(f\"Number of workers = {nw}\")\n            continue\n        elif instring[:1] == '#':\n            continue\n\n\n        #it's a data line\n        if (wftype == 'F'):\n            firmno = int(instring.split(':')[0])\n            outiter = re.finditer(r'\\{.*?\\}',instring.split(':')[1])\n            setlist = []\n            for item in outiter:\n                itemstring = item.group(0).replace('{','').replace('}','')\n                itemset = set([int(itx) for itx in itemstring.split(',')])\n                setlist.append(itemset)  \n            pf[firmno] = setlist\n            #print(f\"pf[{firmno}] = {pf[firmno]}\")\n        elif (wftype == 'W'):\n            temp = instring.split(':')\n            workerno = int(temp[0])\n            firmlist = [itx.strip() for itx in temp[1].split(',')]\n            firmlist = [int(itx) for itx in firmlist]\n            pw[workerno] = firmlist\n            #print(f\"pw[{workerno}] = {firmlist}\")\n    #print(f\"Lines read: {nolines}\")    \n    return(nw,nf,pw,pf)\n        \nif __name__ == \"__main__\":  \n    nw, nf, pw, pf = readData(fpath = '/Volumes/Working/Ministore/MiniMini/Rsync/JMBOX/Research/Matching/MatchData.txt')", "type": "text"}]