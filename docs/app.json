[{"name": "app.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Aug 25 13:33:04 2024\n\n@author: john\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport itertools\nfrom scipy.optimize import linprog\nfrom pandas import option_context\nimport Matching_minmax_stab as Matching\nimport ReadMatchData\n\nimport re\nimport idGraph\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nimport matplotlib.cm as cm\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nimport shinywidgets\nfrom shinywidgets import render_widget, output_widget\n\nimport os\nimport signal\nfrom datetime import datetime\n\nimport networkx as nx\n\nlpchoices = [\"add worker constraint\",\"add 1 set per firm\",\"add stability const.\",\"dualize stab. constr.\",\"card. match\",\"MinMax Stability\",\"Explicit Slacks\",\"Variable Bounds\"]\ncmap = cm.get_cmap('viridis')\n\n\napp_ui = ui.page_navbar( \n    ui.nav_panel(\"Input\", \n        ui.row(\n            ui.HTML(\"<p>Either choose file or type data in below, then click read data when ready to proceed.</p>\"),\n            ),\n        ui.row(\n                ui.column(4,offset = 0,*[ui.input_file(\"file1\", \"Choose .txt File\", accept=[\".csv\", \".CSV\", \".dta\", \".DTA\",\" .txt\", \".TXT\"], multiple=False, placeholder = '', width = \"600px\")]),\n            ),\n        ui.row(\n                ui.input_text_area(\"inputdatalog\",\"Input Data (editable):\",value = '-', width = \"600px\", height = \"400px\")\n            ),        \n        ui.row(\n                #ui.column(3,offset=0,*[ui.input_action_button(\"datalogGo\",\"Show Data (after reading)\",width = '600px')]),\n            ),\n        ui.row(\n                ui.column(2,offset = 0,*[ui.input_action_button(\"doUpdate\",\"Read Input Data\",width = '200px')]),\n                #ui.column(1,offset = 0),\n                ui.column(2,offset = 0,*[ui.download_button(\"download_data\",\"Save Input Data\",width = \"200px\")]),\n                #ui.column(1,offset = 0),\n                ui.column(2,offset = 0,*[ui.input_action_button(\"doReset\",\"Reset Everything\",width = '200px')]),\n                ui.column(6,offset = 0),\n\n                #ui.column(3,offset=0,*[ui.input_action_button(\"datalogGo\",\"Show Data\",width = '300px')]),\n                #ui.column(3,offset=0,*[ui.input_action_button(\"datalogUpdate\",\"Show Data\",width = '300px')])\n            ),\n        ui.row(ui.HTML(\"<p> </p>\"),\n            ),\n        ui.row( \n                ui.HTML(\"<p>Worker and Firm preferences:</p>\"),\n                ui.output_text_verbatim(\"datalog\"),\n            ),        \n        ),\n    ui.nav_panel(\"Linear/Integer Program\",\n        #ui.row(\n                #ui.column(4,offset = 0,*[ui.input_file(\"file1\", \"Choose .txt File\", accept=[\".csv\", \".CSV\", \".dta\", \".DTA\",\" .txt\", \".TXT\"], multiple=False, placeholder = '', width = \"600px\")]),\n            #),\n        ui.row(\n                ui.column(3, offset = 0,*[ui.input_action_button('generateLP',\"Generate LP\")]),\n                ui.column(3, offset = 0,*[ui.input_action_button('solveLP',\"Solve LP\")]),\n                ui.column(6, offset = 0,*[ui.input_checkbox_group(\"genoptions\",\"Options: \",choices = lpchoices,selected = [\"add worker constraint\"],\n                          width = \"500px\",inline = True)]),\n            ),\n        ui.row(\n                #ui.output_data_frame(\"LPOut\"),\n                ui.output_text_verbatim(\"LPOut\"),\n                ui.output_text_verbatim(\"LPSolvedOut\"),\n            ),\n        ui.row(\n             ui.column(3, offset = 0,*[ui.input_action_button('testTU',\"Test TU: (this can take time)\")])\n            ),\n        ui.row(\n             ui.output_text_verbatim(\"TUreport\")\n            ),\n        ui.row(\n             #ui.column(3, offset = 0,*[ui.input_action_button(\"solveIt\",\"Solve LP\")])\n            ),\n        ),\n    ui.nav_panel(\"Enumeration\",\n        ui.row(\n                ui.column(3,offset=0,*[ui.input_action_button(\"goextreme\",\"Enumerate Extreme Points\",width = '300px')]),\n                ui.column(3,offset=0,*[ui.input_radio_buttons(\"stype\",\"Show: \",choices = ['All Extreme Points','Stable Extreme Points Only'],inline = True)]),\n                ui.column(3,offset=0,*[ui.input_radio_buttons(\"vmode\",\"Output: \",choices = ['Terse','Verbose'],selected = 'Terse',inline = True)]),\n                ui.column(3,offset=0,*[ui.input_radio_buttons(\"ext_stab_check\",\"Check Stability from Scratch:\",choices = ['Yes','No'],selected = 'No',inline = True)])\n            ),\n        ui.row(\n                ui.output_text_verbatim(\"extremelog\"),\n            ),\n        ui.row(\n                ui.column(3,offset=0,*[ui.input_action_button(\"gointersection\",\"Show Intersection Graph\",width = '300px')]),\n            ),\n        ui.row(\n                ui.column(6,offset=0,*[ui.output_text_verbatim(\"intgraph\")]), \n                ui.column(6,offset = 0,*[ui.output_text_verbatim(\"datalog2\")]),               \n            ),\n        ui.row(\n            ui.column(6,offset=0, *[ui.input_numeric(\"iset\",\"Show Independent Set\",value = -1,min=-2,max=-1,step=1)]),\n            ),\n        ui.row( \n                ui.column(6, offset = 0,*[ui.output_plot(\"intgraphPic\",width = \"800px\",height=\"800px\")]),\n                height = \"1200px\", \n            ),\n        ),\n    ui.nav_panel(\"PairwiseAdjacency\",\n        ui.row(\n            ui.column(4,offset = 0,*[ui.input_numeric(\"iset1\",\"First Indep. Set (red):\", value = -1, min = -2, max = -1)]),\n            ui.column(4,offset = 0,*[ui.input_numeric(\"iset2\",\"Second Indep. Set (green):\", value = -1, min = -2, max = -1)]),\n            ),\n        ui.row(\n            ui.column(4,offset = 0,*[ui.output_text_verbatim(\"aset1\")]),\n            ui.column(4,offset = 0,*[ui.output_text_verbatim(\"aset2\")]),\n            ),\n        ui.row(\n            ui.column(6, offset = 0, *[ui.output_plot(\"idSetsPic\", width = \"800px\", height=\"800px\")]),\n            ui.column(6, offset = 0, *[ui.output_plot(\"adjacencyPic\", width = \"800px\", height=\"800px\")]),\n            ),\n        ),\n    ui.nav_panel(\"Adjacency\",\n        ui.row(\n            ui.column(6, offset = 0, *[ui.input_action_button(\"doEPAdjacency\",\"Show Extreme Point Adjacency Graph\")]),\n            ui.column(6, offset = 0, *[ui.input_radio_buttons(\"doEPAtext\",\"Show: \",choices = ['Columns','Stability Index'],inline = True)]),\n        ),\n        ui.row(\n            ui.column(9, offset = 0, *[ui.output_plot(\"EPAdjacency\", width = \"1000px\", height = \"1000px\")]),\n            ui.column(3,  offset = 0, *[ui.output_text_verbatim(\"nodelist\")]),\n        ),\n    ),\nunderline = True, title = \"Stable Matcher 3.0 \", position = \"fixed_top\")\n                 \ndef server(input: Inputs, output: Outputs, session: Session):\n    \n    nw = reactive.value(0) # number of workers 1,..,nw\n    nf = reactive.value(0) # number of firms 1,...,fn\n    pw = reactive.value([]) #worker preferences \n    pf = reactive.value([]) # firm preferences\n    cmat = reactive.value([]) #constraint matrix (for TU checking)\n    crhs = reactive.value([]) #righthand sides\n    cobj = reactive.value({}) #objective function\n    df_LP = reactive.value(pd.DataFrame()) # Full generated LP with row and column labels for display mostly\n    res_LP = reactive.value([])\n    solution_LP = reactive.value('') #solution to the LP as a string\n    row_labels_LP = reactive.value([]) #labels to go with LP formulation rows\n    imat_G = reactive.value([]) #incidence matrix of the intersection graph\n    teams_LP = reactive.value([]) #the team that goes with each column of cmat or df_LP\n    firms_LP = reactive.value([]) #the firm that goes with each column of cmat or df_LP\n    stab_constr_LP = reactive.value([]) # just the stability constraint coefficients\n    input_data = reactive.value([]) #this is the cleaned up input data: a list of lines, no spaces, no comments\n    output_data = reactive.value([]) # the \"compiled\" version of the input model for display\n    indep_cols = reactive.value([]) #the characteristic vectors for the independent sets of columns of imat_G (rows=#columns in the LP, #cols = # indep sets)\n    indep_cols_stab = reactive.value([]) #Stability index for each of the sets of independent columns\n    extreme_points = reactive.value('') #text output from extreme point enumeration.\n    TU_msg = reactive.value('')\n\n    @reactive.effect\n    @reactive.event(input.doReset)\n    def doReset():\n        resetIt()\n        # nw.set(0)\n        # nf.set(0)\n        # cmat.set([])\n        # df_LP.set('')\n        # solution_LP.set('')\n        # output_data.set('')\n        # extreme_points.set('')\n        # TU_msg.set('')\n        # imat_G.set([])\n        # ui.update_numeric(\"iset\",value = -2, min = -2)\n\n    def resetIt():\n        nw.set(0)\n        nf.set(0)\n        cmat.set([])\n        df_LP.set('')\n        solution_LP.set('')\n        output_data.set('')\n        extreme_points.set('')\n        TU_msg.set('')\n        imat_G.set([])\n        ui.update_numeric(\"iset\",value = -2, min = -2)\n        res_LP.set([])\n        df_LP.set(pd.DataFrame())\n        indep_cols.set([])\n        imat_G.set([])\n        indep_cols.set([])\n        ui.update_numeric(\"aset1\", value = -1)\n        ui.update_numeric(\"aset2\", value = -1, min = -1)\n  \n\n    @render.download(filename=\"MatchData_\"+str(datetime.now())+\".txt\")\n    def download_data():\n        yield input.inputdatalog()\n\n\n\n    #@reactive.calc\n    @reactive.effect\n    def get_file():\n        #print(f\"$$$$$$$$$$$$$$$$$$Path: {str(input.file1()[0]['datapath'])}\")\n        if input.file1() is None:\n            return('-')\n        else: #Note the ui passes only paths ending in  .csv, .CSV, .dta, .DTA and .txt\n            fpath = str(input.file1()[0]['datapath'])\n            #print(f\"$$$$$$$$$$$$$$$$$$Path: {fpath}\")\n            if (fpath[-4:] == '.txt') or (fpath[-4:] == '.TXT'):\n                data_in = ReadMatchData.readFile(fpath)\n                #temp = \"\\n\".join(data_in)\n                ui.update_text_area(\"inputdatalog\", value = data_in)\n                resetIt()\n                output_data.set('Click Read Input Data')\n                input_data.set(data_in)\n                return(data_in)\n    \n    @reactive.effect\n    @reactive.event(input.doUpdate)\n    def recompile():\n        datalist = []\n        data = input.inputdatalog()\n        if data == '-':\n            return\n            #data = get_file()\n            #if data == '-': return\n        #datalist = input.inputdatalog().split(\"\\n\")\n        datalist = data.split(\"\\n\")\n        nwt, nft, pwt, pft, dataset = ReadMatchData.readData(datalist)\n        nf.set(nft)\n        nw.set(nwt)\n        pf.set(pft)\n        pw.set(pwt)\n        input_data.set(data)\n        if nft == 0:\n            output_data.set(dataset)\n            return\n        outstr = ''\n        outstr = f\"Number of workers = {nwt}. Number of firms = {nft} \\n\"\n        for ix in range(1,nft+1):\n            outstr = outstr + f\"pf[{ix}] = {pft[ix]} \\n\"\n        for ix in range(1,nwt+1):\n            outstr = outstr + f\"pw[{ix}] = {pwt[ix]}\\n\"\n        output_data.set(outstr)\n        #print(\"leaving recompile\")\n        #print(outstr)\n        return\n\n    @render.text\n    #@reactive.event(input.doUpdate)\n    def datalog(): \n        data = output_data()\n        if len(data) == 0: \n            return('Click Read Data after choosing a file or entering data.')\n        else:\n            return(data)\n\n    @render.text\n    #@reactive.event(input.doUpdate)\n    def datalog2(): \n        data = output_data()\n        if len(data) == 0: \n            return('Click Read Data after choosing a file or entering data.')\n        else:\n            return(data)\n\n    #@render.text\n    @reactive.effect\n    @reactive.event(input.goextreme)\n    def extremist():\n        nft = nf()\n        nwt = nw()\n        pft = pf()\n        pwt = pw()\n\n        if nft == 0: return('')\n        if len(cmat()) == 0 : return('')\n\n        #const_mat,rhs,obj,firms,teams,rowlab,stab_constr = Matching.doLP(nwt, nft, pwt, pft, DoOneSet = oneper, DoBounds = False, StabilityConstraints = dostab, Dual = False, Verbose = False)\n        imat = Matching.doIntersectionGraph(cmat())\n        imat_G.set(imat)\n        if (input.stype() == \"All Extreme Points\"): \n            stonly = False\n        else:\n            stonly = True\n        if \"add stability const.\" in input.genoptions():\n            outstring = \"The enumeration process for extreme points requires a non-negative binary constraint matrix.\\n  Remove the stability constraints and try again!\"\n            extreme_points.set(outstring)\n            return\n        else:\n            if input.vmode() == 'Verbose':\n                vm = True\n            else:\n                vm = False\n            if \"add 1 set per firm\" in input.genoptions(): \n                ost = True\n            else:\n                ost = False\n            if input.ext_stab_check() == \"Yes\":\n                StbChk = True\n                if (\"Explicit Slacks\" in input.genoptions()):\n                    outstring = \"Can't do external stability calculation with explicit slacks \\n...if you need this adjust the slack variable encoding.\"\n                    extreme_points.set(outstring)\n                    return\n            else:\n                StbChk = False\n            independent_columns, stability_index,stab_count,outstring = Matching.doIndependentSets(imat, teams_LP() , \n                firms_LP(), pw(), pf(), OneSet = ost, StabConst = stab_constr_LP(), Verbose = vm, StabOnly = stonly,StabCheck = StbChk)\n            indep_cols.set(independent_columns)\n            indep_cols_stab.set(stability_index)\n            nr,nc = independent_columns.shape\n            ui.update_numeric(\"iset\", min=0, max=nc-1)\n            ui.update_numeric(\"iset1\",min=0, max=nc-1)\n            ui.update_numeric(\"iset2\",min=0, max=nc-1)\n            extreme_points.set(outstring)\n        return\n        #return(outstring)\n\n    @render.text\n    def extremelog():\n        if extreme_points() == '': return\n        return(extreme_points())\n\n    @reactive.effect\n    @reactive.event(input.generateLP)\n    def formulate_LP():\n        #nft = parsed_file()\n        solution_LP.set('')\n        res_LP.set([])\n        nwt = nw()\n        nft = nf()\n        oneper = False\n        dostab = False\n        #print(f\"  formulate_LP :: #workers: {nwt}, #firms: {nft}, oneper: {oneper}, dostab: {dostab}\")\n        if nw() == 0: \n            return        \n        oneper = False\n        dostab = False\n        dodual = False\n        cdopt = False\n        doworkers = False\n        minmax = False\n        if (\"add 1 set per firm\" in input.genoptions()):\n            oneper = True\n        if (\"add stability const.\" in input.genoptions()):\n            dostab = True\n        if (\"dualize stab. constr.\" in input.genoptions()):\n            dodual = True\n        if (\"card. match\" in input.genoptions()):\n            dodual = False\n            cdopt = True\n        if (\"add worker constraint\" in input.genoptions()):\n            doworkers = True\n        if (\"MinMax Stability\" in input.genoptions()):\n            minmax = True\n            if not(\"add stability const.\" in input.genoptions()):\n                outstr = \"Minimizing maximum instability objective requires adding stability constraints to the model.  Try again.\"\n                error = pd.DataFrame({'Error':[outstr]})\n                df_LP.set(error)\n                return\n        if (\"Explicit Slacks\"in input.genoptions()):\n            All_Eqn = True\n        else:\n            All_Eqn = False\n        cols, rhs, obj, firm_no, set_assgn, rowlabels, stab_columns = Matching.doLP(nw(), nf(),pw(),pf(),DoWorkers = doworkers,DoOneSet = oneper, StabilityConstraints=dostab, Dual = dodual, OFcard = cdopt, Mxmn = minmax, AllEq = All_Eqn)\n        dfout = Matching.displayLP(constraints = cols, rhs = rhs, obj = obj, teams = set_assgn, firms = firm_no, rowlabels = rowlabels, results = res_LP())\n        #cols, rhs, obj, firm_no, set_assgn, rowlabels, stab_columns = Matching.doLP(mt,DoWorkers = doworkers,DoOneSet = oneper, StabilityConstraints=dostab, Dual = dodual, OFcard = cdopt, Mxmn = minmax)\n        #dfout = Matching.displayLP(mt, results = res_LP())\n        df_LP.set(dfout)\n        cmat.set(cols)\n        cobj.set(obj)\n        crhs.set(rhs)\n        teams_LP.set(set_assgn)\n        firms_LP.set(firm_no)\n        stab_constr_LP.set(stab_columns)\n        row_labels_LP.set(rowlabels)\n\n    #@render.data_frame\n    @render.text\n    @reactive.event(input.generateLP,input.solveLP,input.doReset)\n    def LPOut():\n        dflocal = df_LP()\n        if len(dflocal) == 0:\n            return \"Make sure to choose a file and then click 'Read Input Data' on Input panel before clicking on 'Generate LP' \"\n        return dflocal.to_string() + '\\n'# + solution_LP()\n        #return dflocal\n\n\n\n    @reactive.effect\n    @reactive.event(input.solveLP)\n    def goSolve():\n        linprogstat = [\"Optimization Nominal\", \"Iteration Limit Reached\", \"Infeasible\", \"Unbounded\",\"Numerical Problems, call a professional.\"]\n\n        #now solve it\n        if len(df_LP()) == 0 :\n            solution_LP.set(\"Nothing to solve here.  Forgot to GENERATE LP?\")\n            return\n        if (\"Variable Bounds\" in input.genoptions()):\n            bd = 1\n        else:\n            bd = None\n        lp_res = Matching.solveIt(cmat(), crhs(), cobj(),bds = (0,bd))\n        status = lp_res.status\n        if status == 0:\n            res_LP.set(lp_res)\n        else:\n            outstring = f\"Status: {status}, {linprogstat[status]}\" \n            res_LP.set(lp_res)\n            solution_LP.set(outstring)\n        #solution_LP.set(outstring)\n        return\n\n\n    #@render.data_frame\n    @render.text\n    def LPSolvedOut():\n        if len(firms_LP()) == 0: return\n        if len(res_LP()) == 0: \n            outstring = \"You need to solve the problem before displaying the solution.\"\n            return outstring\n        outstring = Matching.decodeSolution(firms = firms_LP(), teams = teams_LP(),  RowLabels = row_labels_LP(), lp_Result = res_LP())\n        #outstring = Matching.decodeSolution(mt)\n        #dfout = Matching.displayLP(mt)\n        dfout = Matching.displayLP(constraints = cmat(), rhs = crhs(), obj= cobj(), teams = teams_LP(), firms = firms_LP(), rowlabels = row_labels_LP(), results = res_LP())\n        return outstring + '\\n' +dfout.to_string()\n\n\n\n    @render.text\n    @reactive.event(input.gointersection, input.iset)    \n    def intgraph():\n        if (len(imat_G()) == 0): return(' ')\n        ISTU, outstring = Matching.checkTU(imat_G())\n        temp = np.array_str(imat_G())\n        temp += '\\n' + outstring\n        #return(np.array_str(imat_G()))\n        return(temp)\n    \n    @reactive.effect\n    #@render.text\n    @reactive.event(input.testTU)\n    def e_TU():\n        if len(cmat()) == 0: return(\"No model formulated.\")\n        ISTU, outstring = Matching.checkTU(cmat(), Tol = 1e-10)\n        TU_msg.set(outstring)\n        return\n        #return(outstring)\n\n    @render.text\n    def TUreport():\n        if (TU_msg() == ''): return\n        return(TU_msg())\n\n    #@reactive.effect\n    #@reactive.event(input.gointersection)\n    \n    @render.plot\n    @reactive.event(input.gointersection,input.iset)\n    def intgraphPic():\n        if (input.iset() == -2): \n            ui.update_numeric(\"iset\", value = -1,min = -2)\n            fig, ax = plt.subplots(1,1)\n            ax.axis('off')\n            return(plt.draw())\n            #return(' ')\n        if len(imat_G()) == 0: \n            #print(\"No incidence matrix, generate extreme points first.\")\n            ui.update_numeric(\"iset\", value = -1,min = -2)\n            fig, ax = plt.subplots(1,1)\n            ax.axis('off')\n            return(plt.draw())\n            #return(' ')\n        imat = np.array(imat_G())\n        nr,nc = imat.shape  #should be nxn\n        node = idGraph.nodeCoordinates(nr)\n        dotx = [item[0] for item in node]\n        doty = [item[1] for item in node]\n        lines = idGraph.makeSegs(imat,node)\n        fig, ax = plt.subplots(figsize =(8,12))\n        #fig = plt.figure(figsize = (12,9), tight_layout = False)\n        ax.set_xlim(-1.5,1.5)\n        ax.set_ylim(-1.5,1.5)\n        if lines != []:\n            lc = LineCollection(lines,linewidths = 1,colors = 'black')\n            ax.add_collection(lc)\n        ax.plot(dotx,doty,'o',ms = 8, markeredgecolor = 'k', markerfacecolor = 'none')\n        for ix in range(0,nr):\n            pfac = 1.10\n            nfac = 1.5\n            vfac = 1.05\n            if (dotx[ix] < 0 ): \n                fac = nfac\n            else:\n                fac = pfac\n            plt.text(dotx[ix]*fac, doty[ix]*vfac, f\"{ix}={firms_LP()[ix]}: {teams_LP()[ix]}\", fontsize = 10)\n        plt.title(\"Intersection Graph of LP constr.\\n Indep. Set. # = firm # :  {assigned team}\")\n        #add subgraph if appropriate\n        if (input.iset() < 0) :\n            return(plt.draw())\n        active = indep_cols()[:,input.iset()]\n        imatnew = imat.copy()\n        for ix in range(0,nr):\n            for jx in range(0,nc):\n                if ((active[ix] == 0) & (active[jx] == 0)):\n                    imatnew[ix,jx] =0              \n        lines2 = idGraph.makeSegs(imatnew,node)\n        if lines2 != []:\n            lc2 = LineCollection(lines2,linewidths = 2,colors = 'red')\n            ax.add_collection(lc2)\n        for ix in range(0,len(active)):\n            fclstr = 'none'\n            eclstr = 'k'\n            if active[ix] == 1 : \n                eclstr = 'r'\n                fclstr = 'r'\n            ax.plot(dotx[ix],doty[ix],'o',ms = 8, markerfacecolor = fclstr,markeredgecolor = eclstr)\n        return(plt.draw())\n\n\n    @render.text\n    def aset1():\n        if len(imat_G()) == 0: \n            ui.update_numeric(\"iset1\", value =-1)\n            return('No incidence matrix, generate extreme points first. ')\n\n        if input.iset1() < 0: return(' ') #column set number in indep_cols\n        if input.iset2() < 0: return(' ')\n        active = indep_cols()[:,input.iset1()] #0: column not in iset1, 1: column is in iset1\n        outstr = ''\n        for ix in range(len(active)): #for each active column list the firm and team\n            if active[ix] == 1:\n                outstr += f\"column {ix}  firm: {firms_LP()[ix]} team: {teams_LP()[ix]} \\n\"\n        return(outstr)\n\n    @render.text\n    def aset2():\n        if len(imat_G()) == 0: \n            ui.update_numeric(\"iset2\", value = -1)\n            return('No incidence matrix, generate extreme points first. ')\n        if input.iset1() < 0: return(' ') #column set number in indep_cols\n        if input.iset2() < 0: return(' ')\n        active = indep_cols()[:,input.iset2()] #0: column not in iset2, 1: column is in iset1\n        outstr = ''\n        for ix in range(len(active)): #for each active column list the firm and team\n            if active[ix] == 1:\n                outstr += f\"column: {ix} firm: {firms_LP()[ix]} team: {teams_LP()[ix]} \\n\"\n        return(outstr)\n\n    @render.plot\n    #@reactive.event(input.iset1, input.iset2)\n    def idSetsPic():\n        if len(imat_G()) == 0:\n            ui.update_numeric(\"iset1\", value = -1)\n            ui.update_numeric(\"iset2\", value = -1)\n            fig, ax = plt.subplots(1,1)\n            ax.axis('off')\n            return(plt.draw())\n        if (input.iset1() < 0) | (input.iset2() < 0):\n            fig, ax = plt.subplots(1,1)\n            ax.axis('off')\n            return(plt.draw())\n        active1 = indep_cols()[:,input.iset1()]\n        active2 = indep_cols()[:,input.iset2()]\n        #now calculate the symmetric difference\n        active = [ 1 if (((active1[ix] == 1) | (active2[ix] == 1))) else 0 for ix in list(range(0,len(active1)))]\n        #print(f\">>>>>>>>set:{input.iset()} active: {active}\")\n        if len(imat_G()) == 0: \n            fig, ax = plt.subplots(1,1)\n            ax.axis['off']\n            return(plt.draw())\n        imat = np.array(imat_G())\n        nr,nc = imat.shape  #should be nxn\n        node = idGraph.nodeCoordinates(nr)\n        dotx = [item[0] for item in node]\n        doty = [item[1] for item in node]\n        #mask out the columns not in the current independent set\n        imatnew = imat\n        for ix in range(0,nr):\n            for jx in range(0,nc):#retain an arc from imat if and only if both incident nodes are in the symmetric difference\n                if ((active[ix] == 0) & (active[jx] == 0)):\n                    imatnew[ix,jx] =0              \n        lines = idGraph.makeSegs(imatnew,node)\n        fig, ax = plt.subplots(figsize =(8,12))\n        #fig = plt.figure(figsize = (12,9), tight_layout = False)\n        ax.set_xlim(-1.5,1.5)\n        ax.set_ylim(-1.5,1.5)\n        if lines != []:\n            lc = LineCollection(lines,linewidths = 1)\n            ax.add_collection(lc)\n        for ix in range(0,len(active)):\n            eclstr = 'k'\n            fclstr = 'none'\n            if (active1[ix]*active2[ix] == 1):\n                eclstr = 'r'\n                fclstr = 'g'\n            elif active1[ix] == 1 : \n                eclstr = 'r'\n                fclstr = 'r'\n            elif active2[ix] == 1 : \n                eclstr = 'g'\n                fclstr = 'g'\n            ax.plot(dotx[ix],doty[ix],'o',ms=10, markeredgecolor = eclstr,markerfacecolor = fclstr)\n        #ax.plot(dotx,doty,'bo',color = clr2)\n        #offsets for the node labels\n        for ix in range(0,nr):\n            pfac = 1.10\n            nfac = 1.5\n            vfac = 1.05\n            if (dotx[ix] < 0 ): \n                fac = nfac\n            else:\n                fac = pfac\n            plt.text(dotx[ix]*fac, doty[ix]*vfac, f\"{ix}={firms_LP()[ix]}: {teams_LP()[ix]}\", fontsize = 10)\n        a1 = [ix  for ix in list(range(0,len(active1))) if active1[ix]==1]\n        a2 = [ix  for ix in list(range(0,len(active2))) if active2[ix]==1]\n        plt.title(f\"Intersection Graph\\n set: {input.iset1()} columns: {a1} and set:  {input.iset2()} columns: {a2}\")\n        return(plt.draw())\n\n    @render.plot\n    @reactive.event(input.iset1, input.iset2)\n    def adjacencyPic():\n        if (input.iset1() < 0): return\n        if (input.iset2() < 0): return\n        active1 = indep_cols()[:,input.iset1()]\n        active2 = indep_cols()[:,input.iset2()]\n        #now calculate the symmetric difference\n        active = [ 1 if (((active1[ix] == 1) & (active2[ix] == 0)) | ((active1[ix] == 0) & (active2[ix] == 1))) else 0 for ix in list(range(0,len(active1)))]\n        if sum(active) == 0:\n            fig, ax = plt.subplots(1,1)\n            ax.axis('off')\n            return(plt.draw())\n        if len(imat_G())== 0: \n            fig, ax = plt.subplots(1,1)\n            ax.axis('off')\n            ui.update_numeric(\"iset1\", value = -1)\n            ui.update_numeric(\"iset2\", value = -1)\n            return(plt.draw())\n        imat = np.array(imat_G())\n        nr,nc = imat.shape  #should be nxn\n        node = idGraph.nodeCoordinates(nr)\n        dotx = [item[0] for item in node]\n        doty = [item[1] for item in node]\n        #remove arcs that do not connect nodes in the symmetric diff of the independent sets (nodes where active[ix] == 1)\n        imatnew = imat.copy()\n        for ix in range(0,nr):\n            for jx in range(0,nc):#retain an arc from imat if and only if both incident nodes are in the symmetric difference\n                if ((active[ix] == 0) | (active[jx] == 0)):\n                    imatnew[ix,jx] =0              \n        lines = idGraph.makeSegs(imatnew,node)\n        fig, ax = plt.subplots(figsize =(8,12))\n        #fig = plt.figure(figsize = (12,9), tight_layout = False)\n        ax.set_xlim(-1.5,1.5)\n        ax.set_ylim(-1.5,1.5)\n        if lines != []:\n            lc = LineCollection(lines,linewidths = 1)\n            ax.add_collection(lc)\n        for ix in range(0,len(active)):\n            eclstr = 'k'\n            fclstr = 'none'\n            #if (active[ix] == 1):\n            #    eclstr = 'k'\n            #    fclstr = 'k'\n            if (active1[ix]*active2[ix] == 1):\n                xt = 0\n                #eclstr = 'g'\n                #fclstr = 'r'\n            elif active1[ix] == 1 : \n                eclstr = 'r'\n                fclstr = 'r'\n            elif active2[ix] == 1 : \n                eclstr = 'g'\n                fclstr = 'g'\n            ax.plot(dotx[ix],doty[ix],'o',ms = 10, markeredgecolor = eclstr,markerfacecolor = fclstr)\n        #ax.plot(dotx,doty,'bo',color = clr2)\n        #offsets for the node labels\n        for ix in range(0,nr):\n            pfac = 1.10\n            nfac = 1.5\n            vfac = 1.05\n            if (dotx[ix] < 0 ): \n                fac = nfac\n            else:\n                fac = pfac\n            plt.text(dotx[ix]*fac, doty[ix]*vfac, f\"{ix}={firms_LP()[ix]}: {teams_LP()[ix]}\", fontsize = 10)\n        #if sum(sum(imat))==0: return\n\n        a1 = [ix  for ix in list(range(0,len(active1))) if active1[ix]==1]\n        a2 = [ix  for ix in list(range(0,len(active2))) if active2[ix]==1]\n        #create the subgrah of nodes in the symmetric difference\n        sym_dif_nodes = [ix for ix in list(range(0,len(active))) if active[ix]==1]\n        #now create adjacency matrix of just the subgraph of nodes in the symmetric difference\n        imatcols = [ix for ix in sym_dif_nodes]\n        imatnew = imat[:,imatcols]\n        imatnew = imatnew[imatcols,:]\n        #xn,yn = imatnew.shape\n        #if (xn == 0) | (yn == 0): return -2\n        astr = 'No'\n        if (Matching.isConnected_Imat(imatnew)>0): \n            astr = 'Yes'\n        plt.title(f\"Symmetric Diff. \\n set: {input.iset1()} columns: {a1}, set:  {input.iset2()} columns: {a2} Adjacent? {astr}\")\n        return(plt.draw())\n\n    @render.plot\n    @reactive.event(input.doEPAdjacency,input.doReset)\n    def EPAdjacency():\n        imt = imat_G()\n        if len(imt) == 0: \n            fig, ax = plt.subplots(1,1)\n            ax.axis('off')\n            return(plt.draw())\n        #print(f\"EPAdjacency(1): {imt}\")\n        arcs,nonarcs = Matching.extremeAdjacency(indep_cols(),imt)\n        #arcst = [(a[0],a[1]) for a in arcs]\n        #nonarcst = [(a[0],a[1]) for a in nonarcs]\n        idCols = indep_cols()\n        idCols_stab = indep_cols_stab()\n        teams = teams_LP()\n        firms = firms_LP()\n        nr,nc = idCols.shape\n        G = nx.Graph()\n        nodes = list(range(nc))\n        col_map = ['green' if item <=0 else 'red' for item in indep_cols_stab() ]\n        #col_map = [cmap(item[0]/nr) for item in idCols_stab]\n        G.add_nodes_from(nodes)\n        G.add_edges_from(arcs)\n        pos = nx.shell_layout(G)\n        squidge = [1.05, 1.1]\n        shifted_pos ={item: node_pos * squidge for item, node_pos in pos.items()}\n        teamlist = []\n        for icx in range(nc):\n            teamlist.append([f\"{firms[idx]}: {teams[idx]}\" for idx in range(nr) if idCols[idx,icx] == 1])\n        labels = {item: idCols_stab[item] for item in list(range(nc))}\n        #labels = {item: \";\".join(teamlist[item]) for item in list(range(nc))}\n\n        fig, axg = plt.subplots(figsize =(10,10))\n        #axis = plt.gca()\n        print(f\" x: limits: {axg.get_xlim()}\")\n        print(f\" y: limits: {axg.get_ylim()}\")\n        #axg.set_xlim([1.05*x for x in axg.get_xlim()])\n        #axg.set_ylim([1.05*y for y in axg.get_ylim()])\n        #print(f\"EPAdjacency(2): {imt}\")\n        #return(nx.draw_spring(G, ax=axg, with_labels=True))\n        #return(nx.draw_circular(G, ax=axg, with_labels=True))\n        #return(nx.draw_random(G, ax=axg, with_labels=True))\n        nx.draw_shell(G, ax=axg, with_labels=True,node_color = col_map)\n        nx.draw_networkx_labels(G, shifted_pos, labels=labels, font_size = 10,font_weight = 'bold')\n        plt.title(\"Adjacency Graph (an arc indicates two extreme points are adjacent).\")\n        return(plt.draw())\n        #return(nx.draw_spectral(G, ax=axg, with_labels=True))\n        #return(nx.draw_planar(G, ax=axg, with_labels=True))\n        #return(nx.draw_networkx(G))\n    @render.text\n    @reactive.event(input.doEPAdjacency,input.doReset)\n    def nodelist():\n        imt = imat_G()\n        if len(imt) == 0: return ' '\n        idCols = indep_cols()\n        nr,nc = idCols.shape\n        teams = teams_LP()\n        firms = firms_LP()\n        header = \"Node Definitions: [node#]: firm <= team\\n\\n\"\n        teamlist = []\n        for icx in list(range(nc)):\n            #teamlist.append([f\"[{icx}]: \"])\n            #teamlist.append([f\"firm:{firms[idx]}<={teams[idx]}\\n\" for idx in range(nr) if idCols[idx,icx] == 1])\n            teamlist.append([f\"[{icx}]: firm:{firms[idx]}<={teams[idx]}\\n\" for idx in range(nr) if idCols[idx,icx] == 1])\n        labels = [\"\".join(teamlist[item]) for item in list(range(nc))]\n        labels2 = \"\\n\".join(labels)\n        labels2 = header + labels2\n        return(labels2)\napp = App(app_ui, server,debug=False)\n\n\n", "type": "text"}, {"name": "Matching_minmax_stab.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jul 26 09:12:33 2024\n\n@author: john\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport random\nimport itertools as it\nfrom scipy.optimize import linprog\nfrom pandas import option_context\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport time\n\n\n\nrng = np.random.default_rng(1158490)\n\n\ndef solveIt(CONSTRAINTS =  [], RHS = [], OBJ = [],Verbose = False, method = \"highs\", bds = (0,1), AllEq = False):#, method = \"revised simplex\"):\n    linprogstat = [\"Optimization Nominal\", \"Iteration Limit Reached\", \"Infeasible\", \"Unbounded\",\"Numerical Problems, call a professional.\"]\n    if Verbose:\n        print(\"#####################\")\n        print(\"### Solving ##########\")\n        print(\"#####################\")\n    #if (len(CONSTRAINTS) == 0): \n    #    print(\"No constraint matrix specified. Quitting.\")\n    #    return\n    nr, nc = CONSTRAINTS.shape\n    if len(RHS) == 0:\n        RHS = np.ones((nr,1))\n    if len(OBJ) ==0:\n        OBJ = np.ones((nc,1))*-1\n    if AllEq:\n        lp_results = linprog(c = OBJ, A_eq = CONSTRAINTS, b_ub = RHS, bounds = bds)\n    else:\n        lp_results = linprog(c = OBJ, A_ub = CONSTRAINTS, b_ub = RHS, bounds = bds)\n    if lp_results.status == 0:\n        if Verbose:            \n            print(\"Optimization successful\")\n        return(lp_results)\n    else:\n        if Verbose:\n            print(f\"optimization less than successful. Status: {linprogstat[lp_results.status]}\")\n        return(lp_results)\n    \ndef checkTU(mat,Verbose = False, Tol = 1e-10):\n    if Verbose:\n        print(\"#####################\")\n        print(\"### Checking TU #####\")\n        print(\"#####################\")\n    (nrow,ncol) = mat.shape\n    maxsize = min(nrow,ncol)\n    cursize = 2\n    count = 0\n    outstring = ''\n    ISTU = True\n    while cursize <= maxsize :\n        #choose all cursize x cursize sub-matrices \n        rowsets = list(it.combinations(set(np.arange(0,nrow)),cursize))\n        colsets = list(it.combinations(set(np.arange(0,ncol)),cursize))\n        for ix in rowsets:\n            for jx in colsets:\n                a = mat[ix,:]\n                b = a[:,jx]\n                d = np.linalg.det(b)\n                if Verbose:\n                    print(\"\\nTesting\")\n                    print(np.array_str(b))\n                    print(f\"Determinant: {d}\")\n                count = count +1\n                if (np.abs(d)>Tol) & (np.abs(d-1)>Tol) & (np.abs(d+1)>Tol): \n                    ISTU = False\n                    return ISTU, f\">>Is NOT TU<< \\n Determinant: {d} \\n iteration: {count}, \\n Submatrix: \\n {np.array_str(b)} \\n rows: {ix}\\n cols: {jx}\"\n        cursize += 1 \n    return ISTU, f\">>IS TU<< Number of determinants tested: {count}\"\n\n\ndef firmPref(ifirm, preflist, set1, set2):\n    prefers = False\n#    if (set2 not in preflist[ifirm]) & (set1 not in preflist[ifirm]):\n#        return(\"error\")#under current config, this should not happen\n    if set1 not in preflist[ifirm]:\n        prefers = False\n    else:\n        if set2 in preflist[ifirm]:\n            if preflist[ifirm].index(set1)  <  preflist[ifirm].index(set2):\n                prefers = True\n            else:\n                prefers = False\n        else: #in particular if set2 is the empty set (set()) any set in it's preference ordering is preferred\n            prefers = True\n    return(prefers)\n\ndef workerPref(iworker, preflist, firm1, firm2):\n    #note: an unassigned worker prefers remaining unassigned to working at a firm not in his or her preference list\n    #so when we encounter a firm1 value that is not in iworker's preference list we return False always.\n\n    prefers = False\n    #if (firm1 not in preflist[iworker]) & (firm2 not in preflist[iworker]) :\n        #print(f\"worker preference error. Neither firm1 #{firm1} nor firm2 #{firm2} in preference list for worker {iworker}.\")\n        #return(\"error\") # this happens when an a firm not in the worker's firm preference list is compared to no assignment.\n    if firm1 not in preflist[iworker]: #any firm in list is preferred to nothing\n        prefers = False\n    else:\n        if firm2 in preflist[iworker]:\n            if preflist[iworker].index(firm1) < preflist[iworker].index(firm2):\n                prefers = True\n            else:\n                prefers = False\n        else: # firm2 is not in pref list, firm1 is\n            prefers = True\n    return(prefers)    \n    \n    \n    \ndef doLP(nw, nf, pw = [], p=[], DoOneSet = False, DoWorkers = True,  StabilityConstraints = False, Mxmn = False, Dual = False, OFcard = False, AllEq = False, Verbose = False):\n    #Note: workers and firms are indexed 1-offset: workers 1,...,m and firms 1,...,n.  Python arrays/lists are 0-offset, an\n    #array with n components is indexed 0,...,n-1.  Sooo... \n    #p is a list of lists that holds firm preferences: p[1] is a list of sets of workers (teams) in preference order for firm 1. \n    #For example: p[1][0] is the favorite team for firm 1, p[1][2] the next most favored team, etc.\n    #the list of teams starts at 0 the list of firm preference lists starts at 1.   \n    #Same deal for worker preferences but pw[i][0] is the firm number that worker i likes best, p[i][1] second best, etc...\n    #Confusing? Yes, I know...\n    #At this point, no preprocessing is done to remove non firm individually rational teams from firm preferences\n    #non worker individually rational team assignments (teams containin a worker who prefers unemployment to the assigned firm)\n    # are screened out below.\n    if Verbose:\n        print(\"#############################\")\n        print(\"### Generating LP Model #####\")\n        print(\"#############################\")\n    if len(p) == 0:\n        print(\"No firm preferences specified, quitting.\")\n        return([],[],[],[])\n    firm_no = list() #firm for each column\n    set_assgn = list() #set for each column\n    worker_ind = np.zeros((nw+1,1))\n    set_ind = np.zeros((nw+1,1))\n    #*******************************************\n    #construct the incidence matrix column-wise\n    #*******************************************\n    for ix in range(1,nf+1,1): #for each firm 1,...,nf\n        for jx in range(0,len(p[ix]),1): #and each for set in that firm's preference list\n            #create a characteristic or indicator vector (0 if a worker is not in the set 1 if worker is)\n            #a and b are 0 offset lists, pw and p start at 1 --the 0 entry is empty\n\n            a = [1 if item in p[ix][jx] else 0 for item in range(1,nw+1,1)] #the assigned team's characteristic vector\n            #a[item] = 1 if worker # item = 1 is in the jx-th subset of firm i's preference list\n\n            b = [1 if ((a[itx]==1) & (ix not in pw[itx+1])) else 0 for itx in range(0,nw,1) ] #b[itx]=1 if worker itx+1 will not work for firm ix\n            #check that non- worker individually rational team assignments that have been dropped\n            #for ixq in range(0,len(b),1): if (b[ixq] == 1): print(f\"Worker {ixq+1} will not work for firm {ix}\") \n            if (sum(b) > 0): continue #at least one worker in this set will not work for firm ix this team is not individually rational for the workers drop it\n\n            a = [0]+ a  #row entries start at row 1 not row 0\n            worker_ind = np.column_stack((worker_ind,a))\n            firm_no.append(ix)\n            set_assgn.append(p[ix][jx])\n    worker_ind = np.delete(worker_ind,0,1)\n    worker_ind = np.delete(worker_ind,0,0)\n    nr, nc = worker_ind.shape\n    obj = np.zeros(nc)\n    #print(f\">>>>>>>>  After team incidence matrix rows = {nr} columns = {nc}  <<<<<<\")\n    if DoWorkers:\n        rhs = np.ones((nr,1))\n        rowlabels = list(range(1,nw+1))\n        set_ind = worker_ind\n    else: \n        nrtemp , nctemp = worker_ind.shape\n        set_ind = np.empty([0,nctemp])\n        rowlabels = list([])\n        rhs = np.empty([0,1])\n\n    #*******************************************\n    #now add the side constraints of one subset per firm\n    #*******************************************\n    if DoOneSet:\n        for ix in range(0,nf):\n            c = [1 if firm_no[kx] == ix+1 else 0 for kx in range(0,nc)]\n            set_ind = np.vstack((set_ind,c))\n            rhs = np.append(rhs,1)\n            rowlabels.append(\"F_\" + str(ix+1))\n    #righthand side up to this point is 1\n#    (nrow,ncol) = set_ind.shape\n#    rhs = np.ones((nrow + nf + len(firm_no),1))\n#    rhs[nc:len(rhs),0] = -1\n    \n    #*******************************************\n    #  now create stability constraints\n    #*******************************************\n    colset = [tuple(item) for item in set_assgn]\n    colname = list(zip(firm_no,colset))\n    stab_columns = np.ones((1,len(colname))) * 0\n    rowlabels_stab = []\n    for item in colname:\n        ifirm = item[0]\n        iset =  item[1]\n        #start our new row\n        newrow = np.zeros(len(colname))\n        #first put a -1 in column corresponding to current firm/team pair\n        newrow[colname.index((ifirm,iset))] = -1\n        #now scan across all of the columns and put -1's in for all teams that ifirm prefers to iset (has to be a set in ifirms preference relation then ifirm has to prefer it)\n        for setitem in colname:\n            colno = colname.index(setitem)\n            if (setitem[0] != ifirm):\n                continue\n            if (firmPref(ifirm,p,set(setitem[1]),set(iset))):\n                newrow[colno] = -1\n        #now the hard part: for every worker in iset, scan all firm/set pairs. \n        #For sets in which worker iwk resides, put a 1 in the column if iwk prefers that firm\n        for iwk in iset: #for each worker in iset\n            for item_w in colname: #look through all columns (possible firm-team matches)\n                colno_w = colname.index(item_w)\n                ifirm_w = item_w[0]\n                iset_w = item_w[1]\n                if (ifirm_w == ifirm) & (set(iset_w).issubset(set(iset))): #do not apply this to the column being processed (ifirm iset) it's already -1\n                    continue\n                if (iwk in iset_w) & (workerPref(iwk,pw,ifirm_w,ifirm)):  #if our worker iwk is in the set iset_w and prefers ifirm_w\n                    newrow[colno_w] = -1\n        #always generate stability constraints, include in LP formulation only if asked(below)\n        stab_columns = np.vstack((stab_columns,newrow))\n        #rhs_stab = np.append(rhs,-1)\n        rowlabels_stab = rowlabels_stab + [f'St_{ifirm}:{iset}' ]\n        if Dual:\n            obj = obj + newrow*(1)\n    #*******************************************\n    #now put the constraint matrix together\n    #*******************************************\n\n    #objective\n    stab_columns = stab_columns[1:,:] #adjust out the initial column of all zeros\n    if  not Dual: #if we're not dualizing out the stability constraint just put in -1's\n        obj = obj - 1\n        if (OFcard): #unless we're trying to match as many workers as possible, then use set cardinality as objective coef.\n            obj = np.array([len(item) for item in set_assgn])\n            obj = obj * (-1)\n\n    #Stability constraints\n    if StabilityConstraints:\n        crows, ccols = set_ind.shape\n        nrs,ncs = stab_columns.shape\n        nucolmm = 0*np.zeros((crows,1))\n        if (Mxmn):\n            rhs_stab = 0*np.zeros((nrs,1))\n            nucolmm = np.append(nucolmm,np.ones((nrs,1)))\n        else:\n            rhs_stab = -1*np.ones((nrs,1))\n        rhs = np.append(rhs, rhs_stab)\n        rowlabels = rowlabels + rowlabels_stab\n        #set_ind = np.row_stack((set_ind,stab_columns[1:,:]))\n        set_ind = np.vstack((set_ind,stab_columns))\n        if Mxmn:\n            set_ind = np.column_stack((set_ind,nucolmm))\n            obj = 0* obj\n            obj = np.append(obj,-1)\n            firm_no.append(firm_no[-1]+1)\n            set_assgn.append(set())\n\n    #explicit slack variables\n    if AllEq:  \n        #now stick a big identity matrix on the end of the constraint matrix\n        nr, nc = set_ind.shape\n        set_ind = np.column_stack((set_ind,np.identity(nr)))\n        #now fix up the column labels\n        columnfirms = list(range(nc,nc+nr))\n        #columnsets = [set([\"slack\"])]*nr\n        columnsets = [set([\"S\", str(item)]) for item in rowlabels]\n        firm_no = firm_no + columnfirms\n        set_assgn = set_assgn + columnsets\n        obj = np.append(obj, np.array([0]*nr))\n\n    return(set_ind, rhs, obj, firm_no, set_assgn,rowlabels,stab_columns)\n    \n#format, display and save the constraint matrix\n#constraints:  each column is a firm/team assignment first nw rows are the team indicators\n#              second nf rows are the one-subset-to-a-firm constraints\n#              next set of rows (one for each firm/team pair) are the stability constraints\n#              optionally can generate upper and lower bounds for each variable\n#              default objective function is all 1's\n#teams = the team for each column\n#firms = the firm # for each column\n\ndef isStable(pw, pf, firms, teams , icol):\n    #nw = #workers\n    #nf = #firms\n    #pf = firm preferences (maybe not needed) list of lists of workers use entries 1 though nf\n    #pw = worker prefs list of firms use entries 1 through nw\n    #firms = column list of firms\n    #teams = column list of team assigned (list of tuples)\n    #icol = a proposed independent set (i.e.matching) column indicators 1 in the set 0 not)\n    #return: 0 is stable, 1 is not firm individually rational (IR),  2 is not worker IR, 3 is not stable\n    #check firm individual rationality (if assgned a single set is IR because all possible sets for a firm are in that firms choice set)\n    nw = len(pw)-1 # pw, pf are one longer than corresponding number of firms/workers\n    nf = len(pf)-1\n    # #check stability* by hand, one firm and a subset of workers who can improve their\n    # match by deviating.\n    firm_match = [set() for ix in range(nf+1)]#the set matched to each firm (0 for none), index in list is firm number (1 to nf)\n    #worker_match = np.zeros((1,nw+1)) #index in list if worker number \n    worker_match = [0]*(nw+1) #creates a list of 0 of length nw+1. worker_match[iworker] = 0  means iworker is unmatched\n    for ixt in range(0,len(icol)): #iterate through the matching determined by icol\n        if icol[ixt] == 0: continue\n        ixf = firms[ixt]\n        xw = teams[ixt]\n        if (firm_match[ixf] != set()): # if there is a non zero index in firm_match then that firm has already been assigned a team\n            return(1,'Firm matched to two sets.**********************************')\n        else:\n            firm_match[ixf] =  xw # firms[ixt] has been matched to team xw\n            for ixw in xw:\n                if (worker_match[ixw] != 0):\n                    return(4,'Worker matched to more than one firm*******************************') #multiply assigned worker\n                else:\n                    worker_match[ixw]=ixf\n    outstr = \"\"\n    #outstr = \"Implied Matching: \\n\"\n    #firmlst = [f\"Firm: {item} Subset: {firm_match[item]}\" for item in range(1,nf+1)]\n    #worklst = [f\"Worker: {item} Firm: {worker_match[item]}\" for item in range(1,nw+1)]\n    #outstr += \"| \".join(firmlst) + \"\\n\"\n    #outstr += \"| \".join(worklst) + \"\\n\"\n    #outstr += \"\\n\" + f\"Independent Set: {icol[0]}\"\n    #outstr +=  \"\\n\" + f\"Firm Assignments: {firm_match}\" + \"\\n\"\n    #outstr +=  \"\\n\" + f\"Worker Assignments: {worker_match}\" + \"\\n\"\n\n    #now look for a blocking coalition\n    subset_preferring = [set() for ix in range(nf+1)]\n    isBlocked = False\n    for ixf in range(1,nf+1):\n        #for firm ixf find the set of workers that prefers ixf to their current match\n        for ixw in range(1,nw+1):\n            if (workerPref(ixw,pw,ixf,worker_match[ixw])):\n                subset_preferring[ixf].add(ixw)\n        outstr += f\"Workers preferring firm {ixf}: {subset_preferring[ixf]}\\n\"\n    #outstr = outstr + \"\\n\" +f\"Workers preferring each firm {subset_preferring}\" + \"\\n\"\n    #now look for a blocking coalition: one firm and a set of workers\n    #for each firm add take the union of the set of workers that prefer that firm to their matched firm\n    #check to see if this set contains a set that the firm likes better than it's matched set\n    bfirm = 0\n    bset = set(list(range(1,nf+2)))\n    for ixf in range(1,nf+1):\n        if (subset_preferring[ixf] == set()): continue\n        matched_set = firm_match[ixf]\n        test_set = matched_set.union(subset_preferring[ixf]) #test set is union of the set assigned to ixf and proposed blocking worker set\n        for ixs in pf[ixf]: #check each set in ixf's preference list\n            if (ixs.issubset(test_set)) & (firmPref(ixf,pf,ixs,matched_set)): #found a blocking firm and set of workers\n                bset0 = ixs-matched_set\n                if (len(bset0) < len(bset)): \n                    bset = bset0\n                    bfirm = ixf\n                outstr += f\"Blocked by Firm:{ixf} Subset:{ixs} net coalition: {bset0}\\n\"\n                #return(3,f\"Blocked by Firm:{ixf} Subset:{ixs}\")\n                isBlocked = True\n    #outstr += \"Stable\"\n    if isBlocked:\n        outstr += f\"Smallest block,  Firm:{bfirm} Subset:{bset}\\n\"\n        return(3,outstr)\n    outstr += \"Stable\"\n    return(0,outstr)\n\n\ndef displayLP(constraints = [], rhs = [], obj = [], teams = [], firms = [],rowlabels = [], results = []):\n    colset = [str(item) for item in teams]\n    colname = list(zip(firms,colset))\n    #colname = [(item[0],set(item[1])) for item in colname]\n    constraints = pd.DataFrame(data = constraints, columns=colname)\n    constraints['RHS'] = rhs\n    constraints['RowLabels'] = rowlabels\n    constraints.index = [item+1 for item in constraints.index]\n    constraints.loc[constraints.index.max() + 1] = list(obj) + [' ','OBJ']\n    if (len(results) != 0): \n        constraints['Slack'] = np.append(results.ineqlin.residual,0)\n        constraints['Dual'] = np.append(results.ineqlin.marginals,0)\n        x = results.x\n#        constraints.loc[len(constraints)+1] = list(x) + ['X',' ',' ',' ']\n        constraints.loc[len(constraints)+1] = list(x) + ['X','Primal',0,0]\n    #constraints.to_csv(\"LPmodel_2.csv\")\n    return(constraints)\n\ndef decodeSolution(firms = [], teams = [],  RowLabels = [], lp_Result = []):\n    if (len(firms)== 0): \n            msgtxt = \" Input: three vectors of length equal to number of columns in LP.\\n\"\n            msgtxt += \" firms= afirm for each column, teams = a set of workers for each column, \\n\"\n            msgtxt +=   \" solution = solution vector of length = # columns\"\n            return(msgtxt)\n    outstring = ''\n    if  (len(lp_Result)==0): \n        msgtxt = 'No solution to decode.'\n        return(msgtxt)\n    if (lp_Result.status != 0): \n        outstring += \"Optimization misunderstanding status = {lp_Result.status}\"\n        return(outstring)\n    solution = lp_Result.x\n    dual_solution = lp_Result.ineqlin.marginals\n    if len(RowLabels) == 0 :\n        Rowlabels = [zx for zx in range(len(dual_solution))]\n    for zx in range(0,len(solution)):\n        if solution[zx] > 0.0:\n            outstring = outstring + f\"Firm: {firms[zx]}, Assigned Set: {teams[zx]} weight:{solution[zx]} \\n\"\n    for zx in range(0,len(dual_solution)):\n        if dual_solution[zx] != 0.0:\n            outstring = outstring + f\"Row {RowLabels[zx]}, Dual: {dual_solution[zx]}\\n\"\n    return(outstring)\n\ndef doIntersectionGraph(constraint_mat):\n    #mat is a binary array\n    nr, nc = constraint_mat.shape\n    intersection_mat = np.zeros((nc,nc))\n    #for each pair of distinct columns check to see if they have 1's in the same row (inner product > 0)\n    for ir in range(nc):\n        for ic in range(nc):\n            if (sum(constraint_mat[:,ic]*constraint_mat[:,ir]) > 0) & (ir != ic):\n                intersection_mat[ic,ir] = 1\n    return(intersection_mat) #this is the intersection matrix of the columns (dimension nc x nc)\n    \ndef doIndependentSets(inmat,teams,firms, pw, pf, OneSet = False, StabConst = [],StabOnly = False, Verbose = False, StabCheck = False):\n    #very inefficient brute force enumeration\n    #enumerate all of subsets of columns\n    #inmat is the incidence matrix for the intersection graph of the constraint matrix\n    #it is n by n with n= number of columns (and in the same order) as the constraint matrix\n    nr,nc = inmat.shape\n###################\n    # the brute force part:\n    #if the one-set-to-a-firm constraints have been triggered, then find feasible extreme points by \n    #enumerating the power set of the set of columns and saving just the feasible extreme points\n    #if the o-s-t-a-f contraints have not been triggered generate candidate extreme points\n    #by enumerating only those subsets of columns that obey the o-s-t-a-f constraints.  This generates \n    #many fewer columns\n\n    colsubsets = [[]]\n    #if (OneSet ):#always use the more efficient enumeration scheme\n    if (1 == 0):\n        colset = list(range(nc))\n        colsubsets = [[]]\n        for colitem in colset:\n            colsubsets += [item + [colitem] for item in colsubsets]\n    else: # this code alters the extreme point enumeration to consider only extreme points that satisfy the one-set-to-a-firm constraints\n        ftemp = [[indx for indx in range(len(firms)) if firms[indx] == tmp] for tmp in np.unique(firms)]\n        ftemp = [[-1] + fitem for fitem in ftemp]\n        colsubsetsnu = [list(item) for item in it.product(*ftemp)]\n        colsubsets = [[item for item in colitem if item != -1] for colitem in colsubsetsnu]\n\n\n    #now test every subset record results in is_independent \n    #is an indicator for whether or not the given subset is an independent set\n    \n    is_independent = np.ones((1,len(colsubsets))) #assume a subset of columns is independent until proven dependent\n    for indx, item in enumerate(colsubsets): #for each subset of columns\n        #item is the current subset of columns we are working on\n        #indx is the position in colsubsets where that item resides\n        #print(f\">>>>>>>>Testing column set: {item}\")\n        if len(item) == 0: #empty set of columns is independent\n            is_independent[0,indx] = 1\n            continue\n        if len(item) == 1: #any set of columns consisting of one column is independent\n            is_independent[0,indx] = 1\n            continue\n        test_list = list(it.combinations(tuple(item),2)) #all sets of size 2 from the set of columns given by item\n        #check each pair of columns in the current member of colsubsets for common 1's using the intersection matrix\n        for xtpl in test_list:\n            if inmat[xtpl[1],xtpl[0]] == 1: #xptl[1] and xptl[2] have an arc between them (inmat is symmetric as arcs are undirected only need to check one of (i,j) and (j,i))\n                is_independent[0,indx] = 0\n                break;\n    # the list of independent sets is complete. is_independent[ix] = 1 iff the ix'th subset of colsubsets is independent and 0 otherwise\n    # \n    # Now reconstruct the worker subsets and firms that go with them and test each one for stability\n    indcol = np.zeros((nc,1))#record the independent set as a column of column # indicators; #columns = # indep. sets.\n    stability_index = [0] # record the stability index for each independent column\n    solution_count = 0\n    stab_count = 0\n    stringout = ''\n    newstring = ''\n    stringout = f\"Number of column subsets enumerated: {len(colsubsets)} \\n\"\n    stringout += f\"Number of feasible solutions (independent sets) found: {sum(is_independent[0,:])} \\n\"\n    warnstring = '-'\n    for indx,item in enumerate(is_independent[0,:]):\n        sstatus = 0\n        if (item == 1): #this entry corresponds to an independent set\n            newstring = '\\n\\n*************************************\\n'\n            newstring += f\"set #: {indx}, solution count: {solution_count}\" + \"\\n\"\n            newstring += f\"Independent set of columns: {colsubsets[indx]}\" + \"\\n\"\n            newstring += '************************************* \\n'\n            cols = colsubsets[indx] #find the corresponding set of workers\n            newindcol = np.zeros((nc,1)) #create a column length vector to record which columns are active.\n            newstring += \"Independent Set Details:\" + \"\\n\"\n            for itemx in cols:\n                newstring += f\"Firm: {firms[itemx]} Subset: {teams[itemx]}\" + \"\\n\"\n                newindcol[itemx,0] = 1\n            if sum(newindcol[:,0])==0: newstring += '\\n'\n            indcol = np.column_stack((indcol,newindcol))    #add the column to the array of columns\n            #colindicator = [item for item in newindcol[:,0].tolist()] #use to print out a description of the current extreme point\n            #check for stability using the stability constraint\n            stind = 0\n            cstatus = ' '\n            if (len(StabConst) != 0 ):\n                stabtest = np.matmul(StabConst,newindcol[:StabConst.shape[1],0])  #take just the columns of primal variables involved in the stability constraints\n                #the second argument is a one dimensional array, matmul will return a one dimensional array (access as stabtest[ix], not stabtest[ix,0])\n                stind = sum(stabtest >= 0) #matmul seems to return a one dimensional array\n                stability_index.append(stind)\n                if Verbose:\n                    newstring += f\" stability calculation :{np.array_str(stabtest)} \\n\"\n                temp =max(stabtest)\n                if (temp < 0): \n                    cstatus = f\"Stable* stability index = {stind}\" \n                else: cstatus = f\"Not Stable* stability index = {stind}\"\n            else:\n                stind = 0\n                stability_index.append(stind)\n                cstatus = f\"Empty stability constraint matrix, stable.\"\n            #check stability from scratch by checking all possible blocking coalitions\n            if (StabCheck):\n                sstatus,stabstr = isStable(pw,pf,firms,teams,newindcol)\n            else:\n                sstatus = stind\n                stabstr = 'Stability constraints only, external stability check off.'\n                \n            if ((sstatus == 0) & (stind !=0)) | ((sstatus >0) & (stind == 0)):\n                newstring += \"Stability checks disagree!! at ##!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!!\\n\"\n                warnstring = f\"\\n Stability check inconsistency at solution {solution_count} indepset {indx} LP columns {cols}\\n\"\n            if ((sstatus > 0) | (stind >0)):\n                if (not StabOnly): #we are printing details on the non-stable matchings\n                    newstring += f\"{stabstr}\\n --------- Not Stable*  ------\\n sstatus = {sstatus}--cstatus = {cstatus}\\n\"\n                    if Verbose:\n                        newstring +=  stabstr #verbose mode:  report all matchings\n                        #stringout += f\"{np.array_str(stabtest)}\"\n                else: #we are not printing anything for non-stable matchings\n                    newstring = ' '\n            else:\n                stab_count += 1\n                #temp = ','.join(colindicator)\n                #print(f\"Stable match, col indicator: \", colindicator)\n                if Verbose:\n                    newstring += f\"{stabstr} \\n###### *****Stable***  ####### \\n sstatus  = {sstatus}--cstatus = {cstatus} \\n \"\n                else:\n                    newstring += f\" ###### *****Stable***  ######\\n sstatus = {sstatus}--cstatus = {cstatus}  \\n \"\n                \n            stringout += newstring\n            solution_count += 1\n\n    #print(f\">>>>>>>>>>>>>>>>>>> number of stable solutions: {stab_count}\")\n    indcol = indcol[:,1:] #remove the first column of 0's\n    stability_index = stability_index[1:]\n    if stringout == '': \n        stringout = 'Nada'\n    else:\n        stringout += f\"\\n Number of stable* matchings found: {stab_count}\"\n        if warnstring != '-': stringout+= warnstring\n    return(indcol,stability_index,stab_count,stringout) #indcol is the matrix whose columns are the independent sets, stringout is the printable results\n\n              \ndef extremeAdjacency(idCols, indep_mat):  #indep_mat is the intersection graph (adjacency matrix) of the columns                                  \n    arclist = []\n    nonarclist = []\n    nr,nc = idCols.shape #idcols is the matrix of independent sets,\n    #print(\"::::::::::::::  intersection graph ::::::::::::::::::::\")\n    grph = nx.from_numpy_array(indep_mat,create_using=nx.Graph)\n    A = nx.adjacency_matrix(grph)\n    #print(A.toarray())\n    for ix in range(nc):\n        for iy in range(nc):\n            if iy >= ix: break\n            #print(\" \")\n            #print(\"================================++++++++++++++++++++++++++++++++++++++++\")\n            #print(f\"Extreme PT 1(red): (#{ix}), cols:{np.where(np.array(idCols[:,ix]))[0]}, Extreme PT 2(green): (#{iy}), cols: {np.where(np.array(idCols[:,iy]))[0]} \")\n            #ix is and independent set and iy is another independent set\n            active1 = idCols[:,ix]\n            active2 = idCols[:,iy]\n            if (sum(active1) + sum(active2) == 0): continue\n            #if (sum(active1)  == 0): continue\n            #if (sum(active2)  == 0): continue\n         #now calculate the symmetric difference. Note active1 and active2 have the same length equal to the number of columns\n            active = [ 1 if (((active1[ix] == 1) & (active2[ix] == 0)) | ((active1[ix] == 0) & (active2[ix] == 1))) else 0 for ix in list(range(0,len(active1)))]\n            #now find the subgraph of the intersection graph\n            nri,nci = indep_mat.shape  #should be nxn so nri == nci = True\n            if (nri != nci) : \n                print(f\"intersection graph incidence matrix not square! shape: {indep_mat.shape}\")\n                continue\n            #remove arcs not between nodes of the symmetric diff\n            imatnew = indep_mat.copy()\n            for ixi in range(0,nri):\n                for jxi in range(0,nci):\n                    if ((active[ixi] == 0) | (active[jxi] == 0)):\n                        imatnew[ixi,jxi] =0\n            #print(f\"symmetric diff adjacency matrix sum = {sum(sum(imatnew))}\")\n            #print(imatnew)\n            #retain rows and columns corresponding to nodes in the symmetric difference only\n            #create the subgraph of nodes in the symmetric difference\n            sym_dif_nodes = [ix for ix in list(range(0,len(active))) if active[ix]==1]\n            #now create adjacency matrix of just the subgraph of nodes in the symmetric difference\n            imatcols = [ixl for ixl in sym_dif_nodes]\n            imatrows = imatcols\n            imatnew = imatnew[:,imatcols]\n            imatnew = imatnew[imatrows,:]\n            #print(\"symmetric diff adjacency sub-matrix\")\n            #print(imatnew)\n            cres = isConnected_Imat(imatnew)\n            if cres > 0:  \n                arclist.append((ix,iy))\n                #print(f\"Connected: arc: {(ix,iy)}\")\n            else:\n                nonarclist.append((ix,iy))\n            #if cres == 0:\n            #    #print(\"NOT Connected\")\n            if cres == -1:\n                print(f\"Dimension failure.  imat.shape = {imatnew.shape}\") \n            elif cres == -2:\n                print(f\"imat has no nonzero entries.  {imatnew}\")   \n            elif cres == -3:\n                print(f\"No edges recovered from imat. \\n {imatnew}\") \n            elif cres == -4: \n                print(f\"Edge list empty\")     \n    return arclist, nonarclist\n\ndef isConnected_Imat(imat):\n    x,y = imat.shape\n\n    #print(f\"@@@@@  Entering isConnected_Imat dimensions: ({x},{y}) \")\n    #print(imat)\n\n    #if (x == 0) | (y == 0): return -1\n    #if (x != y): return(-1)\n    #if (sum(sum(imat)) == 0): return -2\n\n    grph = nx.from_numpy_array(imat,create_using=nx.Graph)\n    #print(\"checking: adjacency matrix of symmetric diff graph\")\n    #print(nx.adjacency_matrix(grph))\n    if nx.is_connected(grph):\n        return 1\n    else:\n        return 0\n\n\n\nif __name__ == \"__main__\":    \n    \n###################################################################    \n###################################################################    \n###################################################################    \n###################################################################    \n###################################################################    \n    \n     \n\n\n#### Test Examples H4, H8, EO19, B1\n    Example = 'SUBCOMP_12-1'\n    Vbose = False\n    TestTu = False\n    if Example == 'H1':        \n##############Huang Example 1\n        #no stable solution\n        nw = 3  #of workers\n        nf = 3  #of firms\n    \n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n    \n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2,3}]\n        pf[2] = [{1}, {2}]\n        pf[3] = [{2,3}]\n        \n        #enter worker preferences over firms\n        pw[1] = [1,2]\n        pw[2] = [2,1,3]\n        pw[3] = [1,3]\n#################################### \n    elif Example == 'H4':\n##############Huang Example 4\n        #stable matching: firm 1: {1,2}, firm 2: {}, Firm 3: {3}\n        nw = 3  #of workers\n        nf = 2  #of firms\n    \n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n    \n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{1,2}]\n        \n        #enter worker preferences over firms\n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1]\n#################################### \n##############Huang Example 8\n    elif Example == 'H8':\n        nw = 4  #of workers\n        nf = 2  #of firms\n    \n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{3,4}, {1,2}]\n        \n        #worker preferences over firms here\n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1,2]\n        pw[4] = [2]\n        \n    elif Example == 'EO19':\n##################################### \n###Echenique and Oviedo example 19\n        nw = 3\n        nf = 3\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,3}, {1,2}, {2,3}, {1}, {2}, {3}]\n        pf[2] = [{1,3}, {2,3}, {1,2}, {3}, {2}, {1}]\n        pf[3] = [{1,3}, {1,2}, {2,3}, {1}, {2}, {3}]  \n        \n        pw[1] = [1,2,3]\n        pw[2] = [3,2,1]\n        pw[3] = [1,3,2]\n        \n    elif Example == 'EO12':\n##################################### \n###Echenique and Oviedo example 12 no core\n        nw = 3\n        nf = 3\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{2,3}, {1}]\n        pf[3] = [{1,3}, {2}]  \n        \n        pw[1] = [1,3,2]\n        pw[2] = [2,1,3]\n        pw[3] = [3,2,1]\n    elif Example == 'EO11':\n##################################### \n###Echenique and Oviedo example 11 \n        nw = 4\n        nf = 2\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,2},{3,4}, {1,3}, {2,4}, {1},{2},{3},{4}]\n        pf[2] = [{1,2},{1,3}, {2,4}, {3,4}, {1},{2},{3},{4}]\n \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1,2]\n        pw[4] = [1,2]\n    elif Example == 'B1':\n##################################### \n### Bikhchandani substitutes/complements example\n        nw = 4\n        nf = 2\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        \n        #pf[1] = [{1,3}, {2,4},{3}]\n        #pf[2] = [{1,3}, {2,4},{4}]   \n        pf[1] = [{1,3}, {2,4}]\n        pf[2] = [{1,3}, {2,4}]   \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [2,1]\n        pw[4] = [1,2]\n    elif Example == 'B2':\n##################################### \n### Bikhchandani substitutes/complements example\n### with extra sets\n        nw = 4\n        nf = 2\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        \n        #pf[1] = [{1,3}, {2,4},{3}]  \n        #pf[2] = [{1,3}, {2,4},{4}]   \n        pf[1] = [{1,3}, {2,4}]  \n        pf[2] = [{1,3}, {2,4}]   \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1,2]\n        pw[4] = [1,2]\n#######################################\n    elif Example == 'B3':\n##################################### \n### Bikhchandani substitutes/complements example\n### with extra sets\n        nw = 4\n        nf = 2\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        \n        #pf[1] = [{1,3}, {2,4},{3}]  \n        #pf[2] = [{1,3}, {2,4},{4}]   \n        pf[1] = [{1,3}, {2,4}]  \n        pf[2] = [{2,4}, {1,3}]   \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1,2]\n        pw[4] = [1,2]\n#######################################\n\n    elif Example =='TU':\n        nw = 6\n        nf = 4\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        firms = 4\n        pf[1]=[{1,2,3,4}, {2,3}, {3,4}]\n        pf[2]=[{3,4,5,6},{5,6},{6}]\n        pf[3]=[{2,3,4,5},{2,3,4},{3,4}]\n        pf[4]=[{3,4},{2,3,4}, {3,4,5}]\n        workers = 6\n        pw[1]=[1,4,2,3]\n        pw[2]=[4,1,2,3]\n        pw[3]=[2,3,4,1]\n        pw[4]=[3,2,1,4]\n        pw[5]=[1,2,3,4]\n        pw[6]=[1,4,2,3]\n\n    elif Example =='SUBCOMP':\n        nw = 6  #of workers\n        nf = 3  #of firms\n    \n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n\n\n        pf[1]= [{1,4,6},{1,5,6},{2,5,6}]\n        pf[2]= [{2,4,6}]\n        pf[3]= [{2,5}]\n\n        pw[1]=[1,2,3]\n        pw[2]=[1,2,3]\n        pw[3]=[1,2,3]\n        pw[4]=[2,3,0]\n        pw[5]=[2,3,1]\n        pw[6]=[1,2,3]\n\n    elif Example =='BIG':\n        nw = 9  #of workers\n        nf = 6  #of firms\n    \n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        pf[1] = [{1, 2, 3, 4}, {2, 3}, {1, 4}, {1}, {2}] \n        pf[2] = [{8, 9, 7}, {8, 7}, {9, 7}, {8}, {9}] \n        pf[3] = [{1, 3, 5, 7, 9}, {8, 2, 4, 6}] \n        pf[4] = [{8, 9, 6, 7}, {8, 9, 7}, {9, 7}, {8, 9}] \n        pf[5] = [{1}, {2}, {3}, {4}, {5}] \n        pf[6] = [{9}, {8}, {7}, {6}] \n        pw[1] = [1, 2, 3, 4, 5, 6]\n        pw[2] = [4, 2, 6]\n        pw[3] = [6, 5, 4, 3, 2, 1]\n        pw[4] = [1, 2, 3, 4, 5, 6]\n        pw[5] = [4, 2, 6]\n        pw[6] = [6, 5, 4, 3, 2, 1]\n        pw[7] = [1, 2, 3, 4, 5, 6]\n        pw[8] = [4, 2, 6]\n        pw[9] = [6, 5, 4, 3, 2, 1] \n\n    elif Example =='HUPS':\n        nw = 3  #of workers\n        nf = 3  #of firms\n\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1, 2}] \n        pf[2] = [{2, 3}] \n        pf[3] = [{1, 3}] \n        pw[1] = [1, 3]\n        pw[2] = [2, 1]\n        pw[3] = [3, 2]\n\n    elif Example =='HUPS_EX1': \n\n        nw = 6  #of workers\n        nf = 5  #of firms\n\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1, 2, 3}] \n        pf[2] = [{1, 2}, {1}] \n        pf[3] = [{2, 3}, {2}] \n        pf[4] = [{3, 4}, {3}] \n        pf[5] = [{4, 5, 6}] \n        \n        pw[1] = [1, 2, 3, 4, 5]\n        pw[2] = [1, 2, 3, 4, 5]\n        pw[3] = [1, 2, 3, 4, 5]\n        pw[4] = [1, 2, 3, 4, 5]\n        pw[5] = [1, 2, 3, 4, 5]\n        pw[6] = [1, 2, 3, 4, 5]\n\n    elif Example =='SUBCOMP_12-1': \n\n        nw = 4  #of workers\n        nf = 2  #of firms\n\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        \n        pf[1] = [{1,2},{1,4},{3,4},{3,2}]\n        pf[2] = [{3,4},{3,2},{1,4},{1,2}]\n        pw[1] = [1, 2, 3]\n        pw[2] = [1, 2, 3]\n        pw[3] = [1, 2, 3]\n        pw[4] = [3, 2, 1]\n    \n# Exhaustively enumerate worker preferences \n    print(\"########################\")\n    print(f\" Example: {Example}\")\n    print(\"########################\")\n    \n\n    Solve_one = False\n\n    Find_nostab = True\n\n    if (Solve_one):\n        maxminS = False #set up a max min variable and put stability into the objective\n        ####Create the constraint matrix\n        #const_mat,rhs,obj,firms,teams,rowlab,stab_constr = doLP(nw, nf, pw, pf, DoOneSet = False, StabilityConstraints = True, Dual = False, Verbose = Vbose)\n\n        print(f\"At start: nf= {nf}, nw = {nw} \\n pw = {pw} pf={pf}\")\n        const_mat,rhs,obj,firms,teams,rowlab,stab_constr = doLP(nw, nf, pw, pf, DoWorkers = True, DoOneSet = True, StabilityConstraints = True, Dual = True, Mxmn = maxminS, Verbose = Vbose)\n        #imat = doIntersectionGraph(const_mat)\n        #independent_columns,stab_index,stab_count,txt_out = doIndependentSets(imat, teams, firms,pw, pf,  StabConst = stab_constr,StabOnly = True)\n        print(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\")\n        print(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\")\n        #print(txt_out)\n        print(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\")\n        print(\"%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\")\n        dfLP0 = displayLP(constraints = const_mat, rhs = rhs, obj = obj, teams = teams, firms = firms, rowlabels = rowlab)\n        bounds = [(0,1) for item in obj]\n        bounds[-1] = (0,None)\n        solution = solveIt(CONSTRAINTS = const_mat, RHS = rhs, OBJ = obj, Verbose = True) \n        dfLP = displayLP(constraints = const_mat, rhs = rhs, obj = obj, teams = teams, firms = firms, rowlabels = rowlab, results = solution)\n        decodeSolution(firms, teams, solution)\n\n        with pd.option_context('display.max_rows', 50,\n                                'display.max_columns', None,\n                                'display.width', 1000,\n                                'display.precision', 0,\n                                'display.colheader_justify', 'right'):\n            print(dfLP0)\n            print(dfLP)\n            print(\"pw: \")\n            print(pw)\n            print(\"pf: \")\n            print(pf)\n \n    if Find_nostab:\n        count = 0\n        maxstabcount = 0\n        firmlist = list(range(1,nf+1)) + [0]*(nf)\n        print(f\"Firm list: {firmlist}\")\n        firmperm = list(it.permutations(firmlist,nf))\n        workerperm = it.product(range(len(firmperm)),repeat = nw)\n        UNSTABLE = False\n        time0 = time.time()\n        time1 = time0\n        for item in workerperm:\n            pw = [0] + [list(firmperm[itemx]) for itemx in item]\n            const_mat,rhs,obj,firms,teams,rowlab,stab_constr = doLP(nw, nf, pw, pf, DoWorkers = True, DoOneSet = True, StabilityConstraints = False, Mxmn = False, Dual = False, Verbose = Vbose)\n            dfLP = displayLP(constraints = const_mat, rhs = rhs, obj = obj, teams = teams, firms = firms, rowlabels = rowlab)\n            count += 1\n            if (const_mat.size == 0):\n                #count = count + 1\n                #print(\"Null constraint matrix.\")\n                continue\n            if (count <=1):\n                with pd.option_context('display.max_rows', 50,\n                                'display.max_columns', None,\n                                'display.width', 1000,\n                                'display.precision', 0,\n                                'display.colheader_justify', 'right'):\n                    print(const_mat)\n                    print(dfLP)\n                    print(\"pw: \")\n                    print(pw)\n                    print(\"pf: \")\n                    print(pf)\n\n            imat = doIntersectionGraph(const_mat)\n            independent_columns,stab_index,stab_count,txt_out = doIndependentSets(imat, teams, firms,pw, pf,  StabConst = stab_constr,StabOnly = True)\n            if len(stab_index) > 0:\n                if min([item[0]  for item in stab_index]) > 0:\n                    print(f\"No Stable* Solution Found at iteration {count}. Time = {time.time()-time0}\")\n                    print(f\"Preferences: {pw}\")\n                    UNSTABLE = True\n                    break\n                #print(f\"Number of stable solutions: {stab_count} iteration: {count}\")\n            #count = count + 1\n            if stab_count > maxstabcount: maxstabcount = stab_count\n            #if stab_count > 1: print(f\"Mulitple Stable Matchings found: number= {stab_count}, iteration = {count} preferences = {pw}\")\n            if count % 5000 == 0:\n                print(f\"Progress: count = {count}\")\n            if count % 10000 == 0:\n                time2 = time.time()\n                print(f\"Avg iteration per second, last 10,000: {10000/(time2-time1)}, since beginning: {count/(time2-time0)}\")\n                time1 = time2\n                print(f\"Worker preferences: {pw}\")\n        #print(f\"count: {count}\")\n        time2 = time.time()\n        print(f\"Iterations per second: {count/(time2-time0)}\")\n        print(f\"maximal number of stable matchings found in any worker preference instance : {maxstabcount}\")\n        if not(UNSTABLE):       \n            print(f\"All models contained stable solutions count = {count} max # of stable solutions found in any example {maxstabcount}\")\n\n\n\n\n\n\n\n\n    # if Vbose:\n    #     with pd.option_context('display.max_rows', 50,\n    #                            'display.max_columns', None,\n    #                            'display.width', 1000,\n    #                            'display.precision', 0,\n    #                            'display.colheader_justify', 'right'):\n                  \n    #         print(dfLP)\n    \n    \n \n    # if TestTu:\n    #     IS_TU = checkTU(const_mat, Verbose = False)\n    #     if (IS_TU):\n    #         print(\" Is TU\")\n    #     else:\n    #         print(\" is NOT TU\")\n        \n        \n    # solution = solveIt(CONSTRAINTS = const_mat, RHS = rhs, OBJ = obj, Verbose = Vbose) \n\n    # #dfLP = displayLP(constraints = const_mat, rhs = rhs, obj = obj, teams = teams, firms = firms, rowlabels = rowlab, results = solution )\n\n    # decodeSolution(firms, teams, solution)\n    # if solution.status != 0:\n    #     print(\"Uh oh!\")\n    # else:\n    #     dfLP = displayLP(constraints = const_mat, rhs = rhs, obj = obj, teams = teams, firms = firms, rowlabels = rowlab, results = solution )\n    #     if Vbose:\n    #         with pd.option_context('display.max_rows', 50,\n    #                            'display.max_columns', None,\n    #                            'display.width', 1000,\n    #                            'display.precision', 0,\n    #                            'display.colheader_justify', 'right'):                 \n    #             print(dfLP)\n\n    # imat = doIntersectionGraph(const_mat)\n    \n    # with pd.option_context('display.max_rows', 50,\n    #                            'display.max_columns', None,\n    #                            'display.width', 1000,\n    #                            'display.precision', 0,\n    #                            'display.colheader_justify', 'right'):\n    #     print(\"constraint matrix:\")      \n    #     print(const_mat)\n    #     print(\"intersection graph incidence matrix\")\n    #     print(imat)\n    # independent_columns,stab_index,txt_out = doIndependentSets(imat, teams, firms,pw, pf,  StabConst = stab_constr,StabOnly = False)\n    # print(txt_out)\n    # print(\"Extremal (integral) feasible solutions\")\n    # print(independent_columns)\n    # print(\"stability test:\")\n    # print(stab_index)\n    # print(\"Are any of the integer solutions stable?\")\n    # c = np.matmul(stab_constr,independent_columns)\n    # nr,nc = independent_columns.shape\n    # for ixc in range(0,nc):\n    #     col = independent_columns[:,ixc]\n    #     res,stab_status = isStable(pw,pf,firms,teams,col)\n    #     print(f\"{ixc}: stability status = {res}\")\n    # print(\"Stability constraint value:\")\n    # print(c)\n    # print(\"Adjacency arc data for extreme point solutions:\")\n    # extreme_arcs,nonextreme_arcs = extremeAdjacency(independent_columns, imat)\n    # #arcst = [(a[0],a[1]) for a in extreme_arcs]\n    # #nonarcst = [(a[0],a[1]) for a in nonextreme_arcs]\n    # G = nx.Graph()\n    # G.add_edges_from(extreme_arcs)\n    # nx.draw_networkx(G)\n    # plt.show()\n\n    # nonG = nx.Graph()\n    # nonG.add_edges_from(nonextreme_arcs)\n    # nx.draw_networkx(nonG)\n    # plt.show()\n\n\n\n    \n", "type": "text"}, {"name": "ReadMatchData.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Aug 24 23:05:17 2024\n\n@author: john\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport re\ndef readFile(fpath = 'MatchingData.txt'):\n    dfile = open(fpath, mode = 'r')\n    instring = '#'\n    outstr = ''\n    outstring = ''\n    nolines = 0\n    while (instring != ''):\n        instring = dfile.readline()\n        #instring = instring.replace(' ','') #remove spaces\n        if instring == '': continue\n        nolines += 1\n        outstring += instring\n    #outstr = \"\\n\".join(outstring)\n    #print(f\"readFile done: lines read {nolines}\")\n    return(outstring)\n\ndef readData(inlist = []):\n    instring = '#'\n    wftype = ''\n    nolines = 0\n    nf = 0\n    nw = 0\n    pw = []\n    pf = []\n    outstringlist = []\n    if len(inlist) == 0: return\n    for instring in inlist:\n        #first pull out comments, remove extra spaces\n        instring = instring.replace(' ','')\n        instring = instring.split('#')[0] #  if the comment sign # is is in the first column, then split returns '' for instring\n        if instring == '': continue\n        nolines += 1\n        outstringlist.append(instring)\n\n        #decode the type of data line: data, firm indicator, worker indicator or comment\n        if instring[0:5] == 'firms' :\n            wftype = 'F'\n            nf = int(instring.split('=')[1])\n            pf = [[] for itx in range(0,nf + 1)]\n            continue\n        elif instring[0:7] == 'workers':\n            wftype = 'W'\n            nw = int(instring.split('=')[1])\n            pw = [[] for itx in range(0,nw +1)]\n            continue\n        elif instring[:1] == '#': #this should never happen\n            print(f'*****>>>>>>>>>{instring}')\n            continue\n        elif (instring[:1] not in \"123456789\"):\n            return(0,0,[],[],f\"Typo? {instring} => {instring[:1]}\")\n\n        #it's a data line\n        if (wftype == 'F'):\n            #check syntax...sort of\n            if sum([0 if item in \"][}{:0123456789,\" else 1 for item in instring])>0:\n                return(0,0,[],[],f\"Typo? {instring} => {instring[:1]}\")\n            #now process it\n            temp = instring.split(':')\n            if len(temp)<=1: return(0,0,[],[],f\"Missing ':' in {instring}?\")\n            firmno = int(temp[0])\n            if firmno> nf:\n                return(0,0,[],[],f\"firm number out of range at: {instring}\")\n            outiter = re.finditer(r'\\{.*?\\}',instring.split(':')[1])\n            setlist = []\n            for item in outiter:\n                itemstring = item.group(0).replace('{','').replace('}','')\n                itemset = set([int(itx) for itx in itemstring.split(',')])\n                if (itemset in setlist):\n                    return(0,0,[],[],f\"Firm {firmno} has intransitive preferences. Set: {itemstring}\")\n                setlist.append(itemset)  \n            pf[firmno] = setlist\n        elif (wftype == 'W'):\n            #check syntax...sort of\n            if sum([0 if item in \":0123456789,\" else 1 for item in instring])>0:\n                return(0,0,[],[],f\"Typo? {instring}\")\n            #now process it\n            temp = instring.split(':')\n            if len(temp)<=1: return(0,0,[],[],f\"Missing ':' in {instring}?\")\n            workerno = int(temp[0])\n            if workerno > nw: \n                return(0,0,[],[],f\"worker number {workerno} out of range at:{instring}\")\n            firmlist = [itx.strip() for itx in temp[1].split(',')]\n            firmlist = [int(itx) for itx in firmlist if itx != '']\n            if (len(set(firmlist))!= len(firmlist)):\n                return(0,0,[],[],f\"Worker {workerno} preferences are intransitive\")\n            pw[workerno] = firmlist\n    #check numbering consistency\n    for setx in pf[1:]:\n        if setx != []:\n            if (max([max(item) for item in setx]) > nw):\n                return(0,0,[],[],f\"worker number out of range in firm prefs: {setx} workers indicated {nw}\")\n    for firmx in pw[1:]:\n        if max(firmx) > nf:\n            return(0,0,[],[],f\"firm number {max(firmx)} out of range in worker prefs: {firmx} firms indicated = {nf}\")\n    tempstring = '\\n'.join(outstringlist)\n    #print(f\"readData completed data : {tempstring}\")\n    return(nw,nf,pw,pf,tempstring)\n        \nif __name__ == \"__main__\":  \n    nw, nf, pw, pf, dataset= readData(fpath = '/Volumes/Working/Ministore/MiniMini/Rsync/JMBOX/Research/Matching/MatchData.txt')", "type": "text"}, {"name": "idGraph.py", "content": " #!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Sep 8 13:33:04 2024\n\n@author: john\n\"\"\"\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nimport numpy as np\nimport pandas as pd\n\ndef nodeCoordinates(n):\n    #independent graph columns numbered 0 to n-1\n    a = [(round(np.cos(2*i*np.pi/n),2),round(np.sin(2*i*np.pi/n),2)) for i in range(0,n)]\n    return(a)\n\ndef makeSegs(imat,nodes):\n    nr,nc = imat.shape\n    n = nr\n    if len(nodes) != n : return []\n    lines=[[]]\n    for ix in range(0,n):\n        for jx in range(0,n):\n            if (imat[ix,jx] == 1):\n                lines = lines + [[nodes[ix],nodes[jx]]]\n                #print(f\"line from node({ix}) to node({jx}).\")\n    lines = lines[1:]\n    return lines\n        \n\nif __name__ == \"__main__\":  \n\n\n    n=5\n    node = nodeCoordinates(n)\n\n    #make some dots\n    dotx = [item[0] for item in node[1:]]\n    doty = [item[1] for item in node[1:]]\n\n\n    imat = np.zeros((n,n))\n    imat[0,1] = 1\n    imat[1,0] = 1\n    imat[2,3] = 1\n    imat[3,2] = 1\n    imat[3,4] = 1\n    imat[4,3] = 1\n\n    lines = makeSegs(imat)\n\n    # n=5\n    # node = nodeCoordinates(n)\n\n    # lines = [[]]\n    # for ix in range(1,n+1):\n    #     for jx in range(1,ix):\n    #         lines = lines + [[node[ix],node[jx]]]\n    # lines = lines[1:]\n    # #lines2 = [[node[1],node[2]],[node[3],node[2]],[node[3],node[4]],[node[4],node[5]]],[node[5],node[6]],[node[6],node[7]]]\n    # #graph the segment from (0,.25) to (.75,.5) and from (-.75,-.25) to (0,-.5)\n    # lines2 =  [[(0,.25),(.75,.5)],[(-.75,-.25),(0,-.75)]]\n    # lines = [[(0,.75),(.25,.5)],[(-.75,0),(-.25,-.75)]]  \n\n    fig, ax = plt.subplots(figsize =(8,8))\n    #fig = plt.figure(figsize = (12,9), tight_layout = False)\n    ax.set_xlim(-1.5,1.5)\n    ax.set_ylim(-1.5,1.5)\n    lc = LineCollection(lines,linewidths = 2)\n    ax.add_collection(lc)\n    ax.plot(dotx,doty,'bo-')\n    plt.show()\n", "type": "text"}]