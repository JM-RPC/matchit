[{"name": "app.py", "content": " #!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Aug 25 13:33:04 2024\n\n@author: john\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport itertools\nfrom scipy.optimize import linprog\nfrom pandas import option_context\nimport Matching\nimport ReadMatchData\nimport re\nimport idGraph\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\n\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import FileInfo\nimport shinywidgets\nfrom shinywidgets import render_widget, output_widget\n\nimport os\nimport signal\nfrom datetime import datetime\n\n\napp_ui = ui.page_navbar( \n    ui.nav_panel(\"Input\",\n        ui.row(\n            ui.HTML(\"<p>Either choose file or type data in below, then click read data when ready to proceed.</p>\"),\n            ),\n        ui.row(\n                ui.column(4,offset = 0,*[ui.input_file(\"file1\", \"Choose .txt File\", accept=[\".csv\", \".CSV\", \".dta\", \".DTA\",\" .txt\", \".TXT\"], multiple=False, placeholder = '', width = \"600px\")]),\n            ),\n        ui.row(\n                ui.input_text_area(\"inputdatalog\",\"Input Data (editable):\",value = '-', width = \"600px\", height = \"400px\")\n            ),        \n        ui.row(\n                #ui.column(3,offset=0,*[ui.input_action_button(\"datalogGo\",\"Show Data (after reading)\",width = '300px')]),\n            ),\n        ui.row(\n                ui.column(3,offset=0,*[ui.input_action_button(\"doUpdate\",\"Read Input Data\",width = '200px')]),\n                ui.column(2,offset =0),\n                ui.column(3,offset = 0,*[ui.download_button(\"download_data\",\"Save Input Data\",width = \"200px\")]),\n                ui.column(4,offset = 0)\n                #ui.column(3,offset=0,*[ui.input_action_button(\"datalogGo\",\"Show Data\",width = '300px')]),\n                #ui.column(3,offset=0,*[ui.input_action_button(\"datalogUpdate\",\"Show Data\",width = '300px')])\n            ),\n        ui.row(ui.HTML(\"<p> </p>\"),\n            ),\n        ui.row( \n                ui.HTML(\"<p>Worker and Firm preferences:</p>\"),\n                ui.output_text_verbatim(\"datalog\"),\n            ),        \n        ),\n    ui.nav_panel(\"Linear/Integer Program\",\n        #ui.row(\n                #ui.column(4,offset = 0,*[ui.input_file(\"file1\", \"Choose .txt File\", accept=[\".csv\", \".CSV\", \".dta\", \".DTA\",\" .txt\", \".TXT\"], multiple=False, placeholder = '', width = \"600px\")]),\n            #),\n        ui.row(\n                ui.column(3, offset = 0,*[ui.input_action_button('generateLP',\"Generate LP\")]),\n                ui.column(3, offset = 0,*[ui.input_action_button('solveLP',\"Solve LP\")]),\n                ui.column(6, offset = 0,*[ui.input_checkbox_group(\"genoptions\",\"Options: \",choices = [\"add 1 set per firm\",\"add stability const.\",\"dualize stab. constr.\"],\n                          width = \"500px\",inline = True)]),\n            ),\n        ui.row(\n                #ui.output_data_frame(\"LPOut\"),\n                ui.output_text_verbatim(\"LPOut\"),\n                ui.output_text_verbatim(\"LPSolvedOut\"),\n            ),\n        ui.row(\n             ui.column(3, offset = 0,*[ui.input_action_button('testTU',\"Test TU: (this can take time)\")])\n            ),\n        ui.row(\n             ui.output_text_verbatim(\"TUreport\")\n            ),\n        ui.row(\n             #ui.column(3, offset = 0,*[ui.input_action_button(\"solveIt\",\"Solve LP\")])\n            ),\n        ),\n    ui.nav_panel(\"Enumeration\",\n        ui.row(\n                ui.column(3,offset=0,*[ui.input_action_button(\"goextreme\",\"Enumerate Extreme Points\",width = '300px')]),\n                ui.column(6,offset=0,*[ui.input_radio_buttons(\"stype\",\"Show: \",choices = ['All Extreme Points','Stable Extreme Points Only'],inline = True)]),\n            ),\n        ui.row(\n                ui.output_text_verbatim(\"extremelog\"),\n            ),\n        ui.row(\n                ui.column(3,offset=0,*[ui.input_action_button(\"gointersection\",\"Show Intersection Graph\",width = '300px')]),\n            ),\n        ui.row(\n                ui.column(6,offset=0,*[ui.output_text_verbatim(\"intgraph\")]),\n                \n            ),\n        ui.row(\n            ui.column(6,offset=0, *[ui.input_numeric(\"iset\",\"Show Independent Set\",-1,min=-2,max=-1,step=1)]),\n            ),\n        ui.row( \n                ui.column(6, offset = 0,*[ui.output_plot(\"intgraphPic\",width = \"800px\",height=\"800px\")]),\n                ui.column(6, offset = 0,*[ui.output_plot(\"subgraphPic\",width = \"800px\",height=\"800px\")]),\n                height = \"1200px\", \n            ),\n        ),\n#     ui.nav_panel(\"Optimization\",\n#                  ),\nunderline = True, title = \"Stable Matcher 3.0 \")\n                 \ndef server(input: Inputs, output: Outputs, session: Session):\n    \n    nw = reactive.value(0) # number of workers 1,..,nw\n    nf = reactive.value(0) # number of firms 1,...,fn\n    pw = reactive.value([]) #worker preferences \n    pf = reactive.value([]) # firm preferences\n    cmat = reactive.value([]) #constraint matrix (for TU checking)\n    crhs = reactive.value([]) #righthand sides\n    cobj = reactive.value({}) #objective function\n    df_LP = reactive.value(pd.DataFrame()) # Full generated LP with row and column labels for display mostly\n    solution_LP = reactive.value('') #solution to the LP as a string\n    imat_G = reactive.value([]) #incidence matrix of the intersection graph\n    teams_LP = reactive.value([]) #the team that goes with each column of cmat or df_LP\n    firms_LP = reactive.value([]) #the worker that goes with each column of cmat or df_LP\n    stab_constr_LP = reactive.value([]) # just the stability constraint coefficients\n    input_data = reactive.value([]) #this is the cleaned up input data: a list of lines, no spaces, no comments\n    output_data = reactive.value([]) # the \"compiled\" version of the input model for display\n    indep_cols = reactive.value([]) #the independent set characteristic vectors for the current intersection graph\n    \n\n    @render.download(filename=\"MatchData_\"+str(datetime.now())+\".txt\")\n    def download_data():\n        yield input.inputdatalog()\n\n\n\n    #@reactive.calc\n    @reactive.effect\n    def get_file():\n        #print(f\"$$$$$$$$$$$$$$$$$$Path: {str(input.file1()[0]['datapath'])}\")\n        if input.file1() is None:\n            return('-')\n        else: #Note the ui passes only paths ending in  .csv, .CSV, .dta, .DTA and .txt\n            fpath = str(input.file1()[0]['datapath'])\n            #print(f\"$$$$$$$$$$$$$$$$$$Path: {fpath}\")\n            if (fpath[-4:] == '.txt') or (fpath[-4:] == '.TXT'):\n                data_in = ReadMatchData.readFile(fpath)\n                #temp = \"\\n\".join(data_in)\n                ui.update_text_area(\"inputdatalog\", value = data_in)\n                output_data.set('Click Read Input Data')\n                input_data.set(data_in)\n                return(data_in)\n    \n    @reactive.effect\n    @reactive.event(input.doUpdate)\n    def recompile():\n        datalist = []\n        data = input.inputdatalog()\n        if data == '-':\n            return\n            #data = get_file()\n            #if data == '-': return\n        #datalist = input.inputdatalog().split(\"\\n\")\n        datalist = data.split(\"\\n\")\n        nwt, nft, pwt, pft, dataset = ReadMatchData.readData(datalist)\n        nf.set(nft)\n        nw.set(nwt)\n        pf.set(pft)\n        pw.set(pwt)\n        input_data.set(data)\n        if nft == 0:\n            output_data.set(dataset)\n            return\n        outstr = ''\n        outstr = f\"Number of workers = {nwt}. Number of firms = {nft} \\n\"\n        for ix in range(1,nft+1):\n            outstr = outstr + f\"pf[{ix}] = {pft[ix]} \\n\"\n        for ix in range(1,nwt+1):\n            outstr = outstr + f\"pw[{ix}] = {pwt[ix]}\\n\"\n        output_data.set(outstr)\n        #print(\"leaving recompile\")\n        #print(outstr)\n        return\n\n    @render.text\n    #@reactive.event(input.doUpdate)\n    def datalog(): \n        data = output_data()\n        if len(data) == 0: \n            return('Ooops! Maybe forgot to READ the Input Data, or write the data into the box above? \\n click Read Data after reading or entering data.')\n        else:\n            return(data)\n\n\n    @render.text\n    @reactive.event(input.goextreme)\n    def extremelog():\n        nft = nf()\n        nwt = nw()\n        pft = pf()\n        pwt = pw()\n\n        #const_mat,rhs,obj,firms,teams,rowlab,stab_constr = Matching.doLP(nwt, nft, pwt, pft, DoOneSet = oneper, DoBounds = False, StabilityConstraints = dostab, Dual = False, Verbose = False)\n        imat = Matching.doIntersectionGraph(cmat())\n        imat_G.set(imat)\n        if (input.stype() == \"All Extreme Points\"): \n            vbs = True\n        else:\n            vbs = False\n        if \"add stability const.\" in input.genoptions():\n            outstring = \"The enumeration process for extreme points requires a non-negative binary constraint matrix.\\n  Remove the stability constraints and try again!\"\n        else:\n            independent_columns, outstring = Matching.doIndependentSets(imat, teams_LP() , firms_LP(), StabConst = stab_constr_LP(), Verbose = vbs)\n            indep_cols.set(independent_columns)\n            nr,nc = independent_columns.shape\n            ui.update_numeric(\"iset\", min=0, max=nc-1)\n        return(outstring)\n\n    @reactive.effect\n    @reactive.event(input.generateLP)\n    def formulate_LP():\n        #nft = parsed_file()\n        solution_LP.set('')\n        nwt = nw()\n        nft = nf()\n        oneper = False\n        dostab = False\n        #print(f\"  formulate_LP :: #workers: {nwt}, #firms: {nft}, oneper: {oneper}, dostab: {dostab}\")\n        if nw() == 0: \n            return        \n        oneper = False\n        dostab = False\n        dodual = False\n        if (\"add 1 set per firm\" in input.genoptions()):\n            oneper = True\n        if (\"add stability const.\" in input.genoptions()):\n            dostab = True\n        if (\"dualize stab. constr.\" in input.genoptions()):\n            dodual = True\n        cols, rhs, obj, firm_no, set_assgn, rowlabels, stab_columns = Matching.doLP(nw(), nf(),pw(),pf(),DoOneSet = oneper, DoBounds = False, StabilityConstraints=dostab, Dual = dodual)\n        dfout = Matching.displayLP(constraints = cols, rhs = rhs, obj = obj, teams = set_assgn, firms = firm_no, rowlabels = rowlabels)\n        df_LP.set(dfout)\n\n        cmat.set(cols)\n        cobj.set(obj)\n        crhs.set(rhs)\n        teams_LP.set(set_assgn)\n        firms_LP.set(firm_no)\n        stab_constr_LP.set(stab_columns)\n\n    #@render.data_frame\n    @render.text\n    @reactive.event(input.generateLP)\n    def LPOut():\n        dflocal = df_LP()\n        if len(dflocal) == 0:\n            return \"No Data found.  Maybe forgot to READ the Input Data?\"\n        return dflocal.to_string() + '\\n' + solution_LP()\n        #return dflocal\n\n    @reactive.effect\n    @reactive.event(input.solveLP)\n    def goSolve():\n        linprogstat = [\"Optimization Nominal\", \"Iteration Limit Reached\", \"Infeasible\", \"Unbounded\",\"Numerical Problems, call a professional.\"]\n\n        #now solve it\n        if len(df_LP()) == 0:\n            return \"Nothing to solve here.  Forgot to GENERATE LP?\"\n        results,status = Matching.solveIt(cmat(), crhs(), cobj())\n        if status == 0:\n            outstring = Matching.decodeSolution(firms = firms_LP(), teams = teams_LP(),  solution = results)\n        else:\n            outstring = f\"Status: {status}, {linprogstat[status]}\" \n        solution_LP.set(outstring)\n\n\n    #@render.data_frame\n    @render.text\n    def LPSolvedOut():\n        return solution_LP()\n\n\n    @render.text\n    @reactive.event(input.gointersection)    \n    def intgraph():\n        return(np.array_str(imat_G()))\n    \n    @render.text\n    @reactive.event(input.testTU)\n    def TUreport():\n        ISTU, outstring = Matching.checkTU(cmat(), Tol = 1e-10)\n        return outstring\n\n    @render.plot\n    @reactive.event(input.gointersection)\n    def intgraphPic():\n        imat = np.array(imat_G())\n        if imat == []: \n            print(\"No incidence matrix, generate extreme points first.\")\n            return\n        nr,nc = imat.shape  #should be nxn\n        node = idGraph.nodeCoordinates(nr)\n        dotx = [item[0] for item in node]\n        doty = [item[1] for item in node]\n        lines = idGraph.makeSegs(imat,node)\n        fig, ax = plt.subplots(figsize =(8,12))\n        #fig = plt.figure(figsize = (12,9), tight_layout = False)\n        ax.set_xlim(-1.5,1.5)\n        ax.set_ylim(-1.5,1.5)\n        if lines != []:\n            lc = LineCollection(lines,linewidths = 1)\n            ax.add_collection(lc)\n        ax.plot(dotx,doty,'bo')\n        for ix in range(0,nr):\n            pfac = 1.10\n            nfac = 1.4\n            vfac = 1.05\n            if (dotx[ix] < 0 ): \n                fac = nfac\n            else:\n                fac = pfac\n            plt.text(dotx[ix]*fac, doty[ix]*vfac, f\"{ix}={firms_LP()[ix]}: {teams_LP()[ix]}\", fontsize = 10)\n        plt.title(\"Intersection Graph of the Constraint Matrix\\n node/column = firm# :  assigned team\")\n        return(plt.draw())\n\n    @render.plot\n    @reactive.event(input.iset)\n    def subgraphPic():\n        if (input.iset() == -1): return\n        active = indep_cols()[:,input.iset()]\n        print(f\">>>>>>>>set:{input.iset()} active: {active}\")\n        imat = np.array(imat_G())\n        if imat == []: \n            print(\"No incidence matrix, generate extreme points first.\")\n            return\n        nr,nc = imat.shape  #should be nxn\n        node = idGraph.nodeCoordinates(nr)\n        dotx = [item[0] for item in node]\n        doty = [item[1] for item in node]\n        #mask out the columns not in the current independent set\n        imatnew = imat\n        for ix in range(0,nr):\n            for jx in range(0,nc):\n                if ((active[ix] == 0) & (active[jx] == 0)):\n                    imatnew[ix,jx] =0              \n        lines = idGraph.makeSegs(imatnew,node)\n        fig, ax = plt.subplots(figsize =(8,12))\n        #fig = plt.figure(figsize = (12,9), tight_layout = False)\n        ax.set_xlim(-1.5,1.5)\n        ax.set_ylim(-1.5,1.5)\n        if lines != []:\n            lc = LineCollection(lines,linewidths = 1)\n            ax.add_collection(lc)\n        for ix in range(0,len(active)):\n            clstr = 'b'\n            if active[ix] == 1 : clstr = 'r'\n            ax.plot(dotx[ix],doty[ix],'o',color = clstr)\n        #ax.plot(dotx,doty,'bo',color = clr2)\n        for ix in range(0,nr):\n            pfac = 1.10\n            nfac = 1.4\n            vfac = 1.05\n            if (dotx[ix] < 0 ): \n                fac = nfac\n            else:\n                fac = pfac\n            plt.text(dotx[ix]*fac, doty[ix]*vfac, f\"{ix}={firms_LP()[ix]}: {teams_LP()[ix]}\", fontsize = 10)\n        plt.title(f\"Intersection Graph of independent set {input.iset()}\\n columns: {active}\")\n        return(plt.draw())\n        \n\n\n\napp = App(app_ui, server,debug=True)\n\n\n", "type": "text"}, {"name": "Matching.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Jul 26 09:12:33 2024\n\n@author: john\n\"\"\"\nimport pandas as pd\nimport numpy as np\nimport itertools\nfrom scipy.optimize import linprog\nfrom pandas import option_context\n\ndef solveIt(CONSTRAINTS =  [], RHS = [], OBJ = [],Verbose = False):\n    linprogstat = [\"Optimization Nominal\", \"Iteration Limit Reached\", \"Infeasible\", \"Unbounded\",\"Numerical Problems, call a professional.\"]\n    if Verbose:\n        print(\"#####################\")\n        print(\"### Solving ##########\")\n        print(\"#####################\")\n    if (len(CONSTRAINTS) == 0): \n        print(\"No constraint matrix specified. Quitting.\")\n        return\n    \n    nr, nc = CONSTRAINTS.shape\n    bds = [(0,1) for ix in np.arange(0,nc)]\n    if len(RHS) == 0:\n        RHS = np.ones((nr,1))\n    if len(OBJ) ==0:\n        OBJ = np.ones((nc,1))*-1\n    lp_results = linprog(c = OBJ, A_ub = CONSTRAINTS, b_ub = RHS, bounds = bds)\n    if Verbose:\n        if lp_results.status == 0:\n            print(\"Optimization successful\")\n        else:\n            print(f\"optimization less than successful. Status: {linprogstat[lp_results.status]}\")\n            return([],lp_results.status)\n        print(f'Objective : {lp_results.fun}')\n        print(f'Solution: {lp_results.x}')\n        ISINT = [min(np.abs(item-0),np.abs(item-1)) for item in lp_results.x]\n        MXI = max(ISINT)\n        if (MXI > 0.000005): print(\"Solution not integer!\") \n        else: print(f\"Solution integer. Tolerance: {MXI}\")\n    return(lp_results.x,lp_results.status)\n    \ndef checkTU(mat,Verbose = False, Tol = 1e-10):\n    if Verbose:\n        print(\"#####################\")\n        print(\"### Checking TU #####\")\n        print(\"#####################\")\n    (nrow,ncol) = mat.shape\n    maxsize = min(nrow,ncol)\n    cursize = 2\n    count = 0\n    outstring = ''\n    ISTU = True\n    while cursize <= maxsize :\n        #choose all cursize x cursize sub-matrices \n        rowsets = list(itertools.combinations(set(np.arange(0,nrow)),cursize))\n        colsets = list(itertools.combinations(set(np.arange(0,ncol)),cursize))\n        for ix in rowsets:\n            for jx in colsets:\n                a = mat[ix,:]\n                b = a[:,jx]\n                d = np.linalg.det(b)\n                if Verbose:\n                    print(\"\\nTesting\")\n                    print(np.array_str(b))\n                    print(f\"Determinant: {d}\")\n                count = count +1\n                if (np.abs(d)>Tol) & (np.abs(d-1)>Tol) & (np.abs(d+1)>Tol): \n                    ISTU = False\n                    return ISTU, f\">>Is NOT TU<< \\n Determinant: {d} \\n iteration: {count}, \\n Submatrix: \\n {np.array_str(b)}\"\n        cursize += 1 \n    return ISTU, f\">>IS TU<< Number of determinants tested: {count}\"\n\n\ndef firmPref(ifirm, preflist, set1, set2):\n    prefers = False\n    if set2 in preflist[ifirm]:\n        if preflist[ifirm].index(set1)  <  preflist[ifirm].index(set2):\n            prefers = True\n        else:\n            prefers = False\n    else:\n        prefers = False\n    return(prefers)\n\ndef workerPref(iworker, preflist, firm1, firm2):\n    prefers = False\n    if firm1 not in preflist[iworker]:\n        prefers = False\n    else:\n        if firm2 in preflist[iworker]:\n            if preflist[iworker].index(firm1) < preflist[iworker].index(firm2):\n                prefers = True\n            else:\n                prefers = False\n        else:\n            prefers = False\n    return(prefers)    \n    \n    \n    \ndef doLP(nw, nf, pw = [], p=[], DoOneSet = True, DoBounds = False, StabilityConstraints = True, Dual = False, Verbose = False):\n    #Note: workers and firms are indexed 1-offset: workers 1,...,m and firms 1,...,n.  Python arrays/lists are 0-offset, an\n    #array with n components is indexed 0,...,n-1.  Sooo... \n    #p is a list of lists that holds firm preferences: p[1] is a list of sets of workers (teams) in preference order for firm 1. \n    #For example: p[1][0] is the favorite team for firm 1, p[1][2] the next most favored team, etc.\n    #the list of teams starts at 0 the list of firm preference lists starts at 1.   \n    #Same deal for worker preferences but pw[i][0] is the firm number that worker i likes best, p[i][1] second best, etc...\n    #Confusing? Yes, I know...\n    #At this point, no preprocessing is done to remove non firm individually rational teams from firm preferences\n    #non worker individually rational team assignments (teams containin a worker who prefers unemployment to the assigned firm)\n    # are screened out below.\n    if Verbose:\n        print(\"#############################\")\n        print(\"### Generating LP Model #####\")\n        print(\"#############################\")\n    if len(p) == 0:\n        print(\"No firm preferences specified, quitting.\")\n        return([],[],[],[])\n    firm_no = list() #firm for each column\n    set_assgn = list() #set for each column\n    set_ind = np.zeros((nw+1,1))\n    #*******************************************\n    #construct the incidence matrix column-wise\n    #*******************************************\n    for ix in range(1,nf+1,1): #for each firm 1,...,nf\n        for jx in range(0,len(p[ix]),1): #and each set in that firm's preference list\n            #create a characteristic or indicator vector (0 if a worker is not in the set 1 if worker is)\n            #a and b are 0 offset lists, pw and p start at 1 --the 0 entry is empty\n\n            a = [1 if item in p[ix][jx] else 0 for item in range(1,nw+1,1)] #the assigned team's characteristic vector\n            #a[item] = 1 if worker # item = 1 is in the jx-th subset of firm i's preference list\n\n            b = [1 if ((a[itx]==1) & (ix not in pw[itx+1])) else 0 for itx in range(0,nw,1) ] #b[itx]=1 if worker itx+1 will not work for firm ix\n            #check that non- worker individually rational team assignments that have been dropped\n            #for ixq in range(0,len(b),1): if (b[ixq] == 1): print(f\"Worker {ixq+1} will not work for firm {ix}\") \n            if (sum(b) > 0): continue #at least one worker in this set will not work for firm ix this team is not individually rational for the workers drop it\n\n            a = [0]+ a  #row entries start at row 1 not row 0\n            set_ind = np.column_stack((set_ind,a))\n            firm_no.append(ix)\n            set_assgn.append(p[ix][jx])\n    set_ind = np.delete(set_ind,0,1)\n    set_ind = np.delete(set_ind,0,0)\n    nr, nc = set_ind.shape\n    #print(f\">>>>>>>>  After team incidence matrix rows = {nr} columns = {nc}  <<<<<<\")\n    rhs = np.ones((nr,1))\n    rowlabels = list(range(1,nw+1))\n    #columns are now set, construct objective \n    obj = np.zeros(nc)\n    #*******************************************\n    #now add the side constraints of one subset per firm\n    #*******************************************\n    if DoOneSet == True:\n        for ix in range(0,nf):\n            c = [1 if firm_no[kx] == ix+1 else 0 for kx in range(0,nc)]\n            set_ind = np.row_stack((set_ind,c))\n            rhs = np.append(rhs,1)\n            rowlabels.append(\"One per f.\")\n    #righthand side up to this point is 1\n#    (nrow,ncol) = set_ind.shape\n#    rhs = np.ones((nrow + nf + len(firm_no),1))\n#    rhs[nc:len(rhs),0] = -1\n    \n    #*******************************************\n    #now add the variable bounds (not needed may tighten LP relaxation??)\n    #*******************************************\n    if DoBounds ==  True:\n        for ix in range(0,nc):\n            newrowu = np.zeros((1,nc))\n            newrowu[0,ix] = 1\n            set_ind = np.row_stack((set_ind,newrowu))\n            rhs = np.append(rhs,1)\n            rowlabels.append('Variable UB')\n            newrowl = np.zeros((1,nc))\n            newrowl[0,ix] = -1\n            set_ind = np.row_stack((set_ind, newrowl))\n            rhs = np.append(rhs,0)\n            rowlabels.append('Variable LB')\n    #*******************************************\n    #  now add stability constraints\n    #*******************************************\n    colset = [tuple(item) for item in set_assgn]\n    colname = list(zip(firm_no,colset))\n    stab_columns = np.ones((1,len(colname))) * 0\n    rowlabels_stab = []\n    for item in colname:\n        ifirm = item[0]\n        iset =  item[1]\n        #start our new row\n        newrow = np.zeros(len(colname))\n        #first put a -1 in column corresponding to current firm/team pair\n        newrow[colname.index((ifirm,iset))] = -1\n        #now scan across all of the columns and put -1's in for all teams that ifirm prefers to iset (has to be a set in ifirms preference relation then ifirm has to prefer it)\n        for setitem in colname:\n            colno = colname.index(setitem)\n            if (setitem[0] != ifirm):\n                continue\n            if (firmPref(ifirm,p,set(setitem[1]),set(iset))):\n                newrow[colno] = -1\n        #now the hard part: for every worker in iset scan all firm/set pairs put a 1 in the column if all workers in iset  prefers that firm ifirm.\n        for iwk in iset: #for each worker in iset\n            for item_w in colname: #look through all columns (possible firm-team matches)\n                colno_w = colname.index(item_w)\n                ifirm_w = item_w[0]\n                iset_w = item_w[1]\n                if (iwk in iset_w):  #if our worker iwk is in the set iset_w\n                    for iwk_z in iset_w: #unless one or more workers in the set iset_w prefer ifirm to the firm attached to that column ifirm_w\n                        if (workerPref(iwk_z,pw,ifirm_w,ifirm)): newrow[colno_w] = -1\n        #always generate stability constraints, include in LP formulation only if asked(below)\n        stab_columns = np.row_stack((stab_columns,newrow))\n        #rhs_stab = np.append(rhs,-1)\n        rowlabels_stab = rowlabels_stab + [f'St. f: {ifirm}  wkr:{iset}' ]\n        if Dual:\n            obj = obj + newrow*(1)\n    stab_columns = stab_columns[1:,:] #adjust out the initial column of all zeros\n    if  not Dual:\n        obj = obj - 1\n    if StabilityConstraints:\n        nrs,ncs = stab_columns.shape\n        rhs_stab = -1*np.ones((nrs,1))\n        rhs = np.append(rhs, rhs_stab)\n        rowlabels = rowlabels + rowlabels_stab\n        #set_ind = np.row_stack((set_ind,stab_columns[1:,:]))\n        set_ind = np.row_stack((set_ind,stab_columns))\n\n    return(set_ind, rhs, obj, firm_no, set_assgn,rowlabels,stab_columns)\n    \n#format, display and save the constraint matrix\n#constraints:  each column is a firm/team assignment first nw rows are the team indicators\n#              second nf rows are the one-subset-to-a-firm constraints\n#              next set of rows (one for each firm/team pair) are the stability constraints\n#              optionally can generate upper and lower bounds for each variable\n#              default objective function is all 1's\n#teams = the team for each column\n#firms = the firm # for each column\n\n\ndef displayLP(constraints = [], rhs = [], obj = [], teams = [], firms = [],rowlabels = []):\n    colset = [str(item) for item in teams]\n    colname = list(zip(firms,colset))\n    #colname = [(item[0],set(item[1])) for item in colname]\n    constraints = pd.DataFrame(data = constraints, columns=colname)\n    constraints['RHS'] = rhs\n    constraints['RowLabels'] = rowlabels\n    constraints.index = [item+1 for item in constraints.index]\n    constraints.loc[constraints.index.max() + 1] = list(obj) + [' ','OBJ']\n    #constraints.to_csv(\"LPmodel_2.csv\")\n    return(constraints)\n\ndef decodeSolution(firms = [], teams = [],  solution = []):\n    if (len(firms)== 0): \n            msgtxt = \" Input: three vectors of length equal to number of columns in LP.\\n\"\n            + \" firms= afirm for each column, teams = a set of workers for each column, \\n\"\n            +   \" solution = solution vector of length = # columns\"\n            print (msgtxt)\n    outstring = ''\n    for zx in range(0,len(solution)):\n        if solution[zx] > 0.0:\n            outstring = outstring + f\"Firm: {firms[zx]}, Assigned Set: {teams[zx]} weight:{solution[zx]} \\n\"\n    return(outstring)\n\ndef doIntersectionGraph(constraint_mat):\n    #mat is a binary array\n    nr, nc = constraint_mat.shape\n    intersection_mat = np.zeros((nc,nc))\n    #for each pair of distinct columns check to see if they have 1's in the same row (inner product > 0)\n    for ir in range(nc):\n        for ic in range(nc):\n            if (sum(constraint_mat[:,ic]*constraint_mat[:,ir]) > 0) & (ir != ic):\n                intersection_mat[ic,ir] = 1\n    return(intersection_mat)\n    \ndef doIndependentSets(inmat,teams,firms, StabConst = [],Verbose = False):\n    #very inefficient brute force enumeration\n    #enumerate all of subsets of columns\n    #inmat is the incidence matrix for the intersection graph of the constraint matrix\n    #it is n by n with n= number of columns (and in the same order) as the constraint matrix\n    nr,nc = inmat.shape\n\n    # first create a list that contains the power set of the set of columns (this is the brute force part)\n    colset = list(range(nc))\n    colsubsets = [[]]\n    for colitem in colset:\n        colsubsets += [item + [colitem] for item in colsubsets]\n\n    #print(f\" Cardinality of power set: {len(colsubsets)}\")  #just checking\n\n    #now test every subset is_inedependent \n    #is an indicator for whether or not the given subset is an independent set\n    \n    is_independent = np.ones((1,len(colsubsets))) #assume a subset of columns is independent until proven dependent\n    for indx, item in enumerate(colsubsets): #for each subset of columns\n        #item is the current subset of columns we are working on\n        #indx is the position in colsubsets where that item resides\n        print(f\">>>>>>>>Testing column set: {item}\")\n        if len(item) == 0: \n            is_independent[0,indx] = 1\n            continue\n        if len(item) == 1: continue\n        test_list = list(itertools.combinations(tuple(item),2)) #all sets of size 2 from the set of columns given by item\n        for xtpl in test_list:\n            if inmat[xtpl[1],xtpl[0]] == 1: #xptl[1] and xptl[2] have an arc between them (inmat is symmetric as arcs are undirected only need to check one of (i,j) and (j,i))\n                is_independent[0,indx] = 0\n                break;\n    # the list of independent sets is complete. Now reconstruct the worker subsets and firms that go with them\n    indcol = np.zeros((nc,1))\n    solution_count = 0\n    stringout = ''\n    for indx,item in enumerate(is_independent[0,:]):\n        if (item == 1): #this entry corresponds to an independent set\n            newstring = ''\n            newstring = newstring + f\"\\n #{solution_count}  Independent set of columns: {colsubsets[indx]}\" + \"\\n\"\n            cols = colsubsets[indx] #find the corresponding set of workers\n            newindcol = np.zeros((nc,1)) #create a column length vector to record which columns are active.\n            for itemx in cols:\n                newstring = newstring + f\"Firm: {firms[itemx]} Subset: {teams[itemx]}\" + \"\\n\"\n                newindcol[itemx,0] = 1\n            indcol = np.column_stack((indcol,newindcol))    \n            if (len(StabConst) != 0 ):\n                stabtest = np.matmul(StabConst,newindcol)\n                newstring += f\" stability calculation :{np.array_str(stabtest[:,0])} \\n\"\n                if max(stabtest[:,0]) > -1.0 :\n                    newstring += \"----------------- Not Stable*  ---------------\\n\"\n                    if (Verbose): \n                        stringout += newstring #verbose mode:  report all matchings\n                        #stringout += f\"{np.array_str(stabtest)}\"\n                else:\n                    newstring += \"+++++++++++++++++  Stable*    ++++++++++++++++\\n \"\n                    stringout = stringout + newstring\n            else:\n                stringout = stringout + newstring\n            solution_count += 1\n    indcol = indcol[:,1:]\n    return(indcol,stringout)\n            \n    \nif __name__ == \"__main__\":    \n    \n###################################################################    \n###################################################################    \n###################################################################    \n###################################################################    \n###################################################################    \n    \n     \n    \n#### Test Examples H4, H8, EO19, B1\n    Example = 'B1'\n    Vbose = True\n    TestTu = False\n    if Example == 'H1':\n##############Huang Example 1\n        #no stable solution\n        nw = 3  #of workers\n        nf = 3  #of firms\n    \n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n    \n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2,3}]\n        pf[2] = [{1}, {2}]\n        pf[3] = [{2,3}]\n        \n        #enter worker preferences over firms\n        pw[1] = [1,2]\n        pw[2] = [2,1,3]\n        pw[3] = [1,3]\n#################################### \n    elif Example == 'H4':\n##############Huang Example 4\n        #stable matching: firm 1: {1,2}, firm 2: {}, Firm 3: {3}\n        nw = 3  #of workers\n        nf = 2  #of firms\n    \n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n    \n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{1,2}]\n        \n        #enter worker preferences over firms\n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1]\n#################################### \n##############Huang Example 8\n    elif Example == 'H8':\n        nw = 4  #of workers\n        nf = 2  #of firms\n    \n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        # Enter firm preferences over subsets here\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{3,4}, {1,2}]\n        \n        #worker preferences over firms here\n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1,2]\n        pw[4] = [2]\n        \n    elif Example == 'EO19':\n##################################### \n###Echenique and Oviedo example 19\n        nw = 3\n        nf = 3\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,3}, {1,2}, {2,3}, {1}, {2}, {3}]\n        pf[2] = [{1,3}, {2,3}, {1,2}, {3}, {2}, {1}]\n        pf[3] = [{1,3}, {1,2}, {2,3}, {1}, {2}, {3}]  \n        \n        pw[1] = [1,2,3]\n        pw[2] = [3,2,1]\n        pw[3] = [1,3,2]\n        \n    elif Example == 'EO12':\n##################################### \n###Echenique and Oviedo example 12 no core\n        nw = 3\n        nf = 3\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,2}, {3}]\n        pf[2] = [{2,3}, {1}]\n        pf[3] = [{1,3}, {2}]  \n        \n        pw[1] = [1,3,2]\n        pw[2] = [2,1,3]\n        pw[3] = [3,2,1]\n    elif Example == 'EO11':\n##################################### \n###Echenique and Oviedo example 11 \n        nw = 4\n        nf = 2\n        pf = list(range(0,nf+1))\n        pw = list(range(0,nw + 1))\n\n        pf[1] = [{1,2},{3,4}, {1,3}, {2,4}, {1},{2},{3},{4}]\n        pf[2] = [{1,2},{1,3}, {2,4}, {3,4}, {1},{2},{3},{4}]\n \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [1,2]\n        pw[4] = [1,2]\n    elif Example == 'B1':\n##################################### \n### Bikhchandani substitutes/complements example\n        nw = 4\n        nf = 2\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        \n        #pf[1] = [{1,3}, {2,4},{3}]\n        #pf[2] = [{1,3}, {2,4},{4}]   \n        pf[1] = [{1,3}, {2,4}]\n        pf[2] = [{1,3}, {2,4}]   \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [2,1]\n        pw[4] = [1,2]\n    elif Example == 'B2':\n##################################### \n### Bikhchandani substitutes/complements example\n### with extra sets\n        nw = 4\n        nf = 2\n        pf = list(range(0,nf + 1))\n        pw = list(range(0,nw + 1))\n        \n        pf[1] = [{1,3}, {2,4},{3}]\n        pf[2] = [{1,3}, {2,4},{4}]   \n        \n        pw[1] = [1,2]\n        pw[2] = [2,1]\n        pw[3] = [2,1]\n        pw[4] = [1,2]\n        \n        \n    \n# Try an example \n    print(\"########################\")\n    print(f\" Example: {Example}\")\n    print(\"########################\")\n    \n    ####Create the constraint matrix\n    const_mat,rhs,obj,firms,teams,rowlab,stab_constr = doLP(nw, nf, pw, pf, DoOneSet = True, DoBounds = False, StabilityConstraints = False, Dual = False, Verbose = Vbose)\n    \n    dfLP = displayLP(constraints = const_mat, rhs = rhs, obj = obj, teams = teams, firms = firms, rowlabels = rowlab)\n    if Vbose:\n        with pd.option_context('display.max_rows', 50,\n                               'display.max_columns', None,\n                               'display.width', 1000,\n                               'display.precision', 0,\n                               'display.colheader_justify', 'right'):\n                  \n            print(dfLP)\n    \n    \n    \n    if TestTu:\n        IS_TU = checkTU(const_mat, Verbose = Vbose)\n        if (IS_TU):\n            print(\" Is TU\")\n        else:\n            print(\" is NOT TU\")\n        \n        \n    solution,stat = solveIt(CONSTRAINTS = const_mat, RHS = rhs, OBJ = obj, Verbose = Vbose)  \n    if stat == 0:    \n        decodeSolution(firms, teams, solution)\n    else: \n        print(\"Uh oh!\")\n        \n    imat = doIntersectionGraph(const_mat)\n    \n    with pd.option_context('display.max_rows', 50,\n                               'display.max_columns', None,\n                               'display.width', 1000,\n                               'display.precision', 0,\n                               'display.colheader_justify', 'right'):\n        print(\"constraint matrix:\")      \n        print(const_mat)\n        print(\"intersection graph incidence matrix\")\n        print(imat)\n        independent_columns,txt_out = doIndependentSets(imat, teams, firms, StabConst = stab_constr)\n        print(txt_out)\n        print(\"Extremal (integral) feasible solutions\")\n        print(independent_columns)\n        print(\"Are any of the integer solutions stable?\")\n        c = np.matmul(stab_constr,independent_columns)\n        print(c)\n\n    ", "type": "text"}, {"name": "ReadMatchData.py", "content": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Aug 24 23:05:17 2024\n\n@author: john\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport re\ndef readFile(fpath = 'MatchingData.txt'):\n    dfile = open(fpath, mode = 'r')\n    instring = '#'\n    outstr = ''\n    outstring = ''\n    nolines = 0\n    while (instring != ''):\n        instring = dfile.readline()\n        #instring = instring.replace(' ','') #remove spaces\n        if instring == '': continue\n        nolines += 1\n        outstring += instring\n    #outstr = \"\\n\".join(outstring)\n    print(f\"readFile done: lines read {nolines}\")\n    return(outstring)\n\ndef readData(inlist = []):\n    instring = '#'\n    wftype = ''\n    nolines = 0\n    nf = 0\n    nw = 0\n    pw = []\n    pf = []\n    outstringlist = []\n    if len(inlist) == 0: return\n    for instring in inlist:\n        #first pull out comments, remove extra spaces\n        instring = instring.replace(' ','')\n        instring = instring.split('#')[0] #  if the comment sign # is is in the first column, then split returns '' for instring\n        if instring == '': continue\n        nolines += 1\n        outstringlist.append(instring)\n\n        #decode the type of data line: data, firm indicator, worker indicator or comment\n        if instring[0:5] == 'firms' :\n            wftype = 'F'\n            nf = int(instring.split('=')[1])\n            pf = [[] for itx in range(0,nf + 1)]\n            continue\n        elif instring[0:7] == 'workers':\n            wftype = 'W'\n            nw = int(instring.split('=')[1])\n            pw = [[] for itx in range(0,nw +1)]\n            continue\n        elif instring[:1] == '#': #this should never happen\n            print(f'*****>>>>>>>>>{instring}')\n            continue\n        elif (instring[:1] not in \"123456789\"):\n            return(0,0,[],[],f\"Typo? {instring}\")\n\n        #it's a data line\n        if (wftype == 'F'):\n            #check syntax...sort of\n            if sum([0 if item in \"][}{:0123456789,\" else 1 for item in instring])>0:\n                return(0,0,[],[],f\"Typo? {instring}\")\n            #now process it\n            firmno = int(instring.split(':')[0])\n            if firmno> nf:\n                return(0,0,[],[],f\"firm number out of range at: {instring}\")\n            outiter = re.finditer(r'\\{.*?\\}',instring.split(':')[1])\n            setlist = []\n            for item in outiter:\n                itemstring = item.group(0).replace('{','').replace('}','')\n                itemset = set([int(itx) for itx in itemstring.split(',')])\n                setlist.append(itemset)  \n            pf[firmno] = setlist\n        elif (wftype == 'W'):\n            #check syntax...sort of\n            if sum([0 if item in \":0123456789,\" else 1 for item in instring])>0:\n                return(0,0,[],[],f\"Typo? {instring}\")\n            #now process it\n            temp = instring.split(':')\n            workerno = int(temp[0])\n            if workerno > nw: \n                return(0,0,[],[],f\"worker number {workerno} out of range at:{instring}\")\n            firmlist = [itx.strip() for itx in temp[1].split(',')]\n            firmlist = [int(itx) for itx in firmlist]\n            pw[workerno] = firmlist\n    #check numbering consistency\n    for setx in pf[1:]:\n        if (max([max(item) for item in setx]) > nw):\n            return(0,0,[],[],f\"worker number out of range in firm prefs: {setx} workers indicated {nw}\")\n    for firmx in pw[1:]:\n        if max(firmx) > nf:\n            return(0,0,[],[],f\"firm number {max(firmx)} out of range in worker prefs: {firmx} firms indicated = {nf}\")\n    tempstring = '\\n'.join(outstringlist)\n    #print(f\"readData completed data : {tempstring}\")\n    return(nw,nf,pw,pf,tempstring)\n        \nif __name__ == \"__main__\":  \n    nw, nf, pw, pf, dataset= readData(fpath = '/Volumes/Working/Ministore/MiniMini/Rsync/JMBOX/Research/Matching/MatchData.txt')", "type": "text"}, {"name": "idGraph.py", "content": " #!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sun Sep 8 13:33:04 2024\n\n@author: john\n\"\"\"\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nimport numpy as np\nimport pandas as pd\n\ndef nodeCoordinates(n):\n    #independent graph columns numbered 0 to n-1\n    a = [(round(np.cos(2*i*np.pi/n),2),round(np.sin(2*i*np.pi/n),2)) for i in range(0,n)]\n    return(a)\n\ndef makeSegs(imat,nodes):\n    nr,nc = imat.shape\n    n = nr\n    if len(nodes) != n : return []\n    lines=[[]]\n    for ix in range(0,n):\n        for jx in range(0,ix):\n            if (imat[ix,jx] == 1):\n                lines = lines + [[nodes[ix],nodes[jx]]]\n    lines = lines[1:]\n    return lines\n        \n\nif __name__ == \"__main__\":  \n\n\n    n=5\n    node = nodeCoordinates(n)\n\n    #make some dots\n    dotx = [item[0] for item in node[1:]]\n    doty = [item[1] for item in node[1:]]\n\n\n    imat = np.zeros((n,n))\n    imat[0,1] = 1\n    imat[1,0] = 1\n    imat[2,3] = 1\n    imat[3,2] = 1\n    imat[3,4] = 1\n    imat[4,3] = 1\n\n    lines = makeSegs(imat)\n\n    # n=5\n    # node = nodeCoordinates(n)\n\n    # lines = [[]]\n    # for ix in range(1,n+1):\n    #     for jx in range(1,ix):\n    #         lines = lines + [[node[ix],node[jx]]]\n    # lines = lines[1:]\n    # #lines2 = [[node[1],node[2]],[node[3],node[2]],[node[3],node[4]],[node[4],node[5]]],[node[5],node[6]],[node[6],node[7]]]\n    # #graph the segment from (0,.25) to (.75,.5) and from (-.75,-.25) to (0,-.5)\n    # lines2 =  [[(0,.25),(.75,.5)],[(-.75,-.25),(0,-.75)]]\n    # lines = [[(0,.75),(.25,.5)],[(-.75,0),(-.25,-.75)]]  \n\n    fig, ax = plt.subplots(figsize =(8,8))\n    #fig = plt.figure(figsize = (12,9), tight_layout = False)\n    ax.set_xlim(-1.5,1.5)\n    ax.set_ylim(-1.5,1.5)\n    lc = LineCollection(lines,linewidths = 2)\n    ax.add_collection(lc)\n    ax.plot(dotx,doty,'bo-')\n    plt.show()\n", "type": "text"}]